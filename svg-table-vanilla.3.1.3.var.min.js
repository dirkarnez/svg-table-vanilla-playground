var SVGTableVanilla;
/******/ // The require scope
/******/ var __webpack_require__ = {};
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "__private__": () => (/* reexport */ __private__),
  "convertToKebabCaseProps": () => (/* reexport */ convertToKebabCaseProps),
  "createRenderedString": () => (/* reexport */ createRenderedString),
  "createVanillaElement": () => (/* reexport */ createVanillaElement),
  "default": () => (/* reexport */ dist),
  "kebabize": () => (/* reexport */ kebabize),
  "simpleValue": () => (/* reexport */ simpleValue)
});

;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/consts.js
const INTERNAL_CSS_VARS = Object.freeze({
    borderLineColor: '--line-default-stroke',
    textColor: '--text-default-color',
});
const DEFAULT_COLORS = Object.freeze({
    border: '#000',
});
const DEFAULT_WITH_CSSVARS = Object.freeze({
    border: `var(${INTERNAL_CSS_VARS.borderLineColor}, ${DEFAULT_COLORS.border})`,
});
//# sourceMappingURL=consts.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/utils.js

const getValFromArr = (arr, pos) => {
    if (arr.length === 4) {
        switch (pos) {
            case 'left':
                return arr[3];
            case 'right':
                return arr[1];
            case 'bottom':
                return arr[2];
            default:
            case 'top':
                return arr[0];
        }
    }
    else if (arr.length === 2) {
        switch (pos) {
            case 'left':
                return arr[1];
            case 'right':
                return arr[1];
            case 'top':
            case 'bottom':
            default:
                return arr[0];
        }
    }
    return;
};
const getWid = (widths, pos) => {
    if (widths === undefined)
        return 0;
    if (typeof widths === 'number')
        return widths;
    if (Array.isArray(widths)) {
        const val = getValFromArr(widths, pos);
        if (val !== undefined)
            return val;
    }
    console.error('Invalid widths type: ', widths, 'for', pos, ' should be number or [number, number, number, number] or [number, number]');
    return 0;
};
const getWidVisible = (widths) => {
    if (widths === undefined)
        return false;
    if (typeof widths === 'number')
        return widths > 0;
    if (Array.isArray(widths)) {
        return widths.some(w => w > 0);
    }
    return false;
};
const getStrokeColor = (colors, pos) => {
    if (!colors)
        return undefined;
    if (typeof colors === 'string')
        return colors;
    if (Array.isArray(colors)) {
        if (pos) {
            const val = getValFromArr(colors, pos);
            if (val !== undefined)
                return val;
        }
        else {
            return (colors && Array.isArray(colors) ? colors[0] : colors) ?? DEFAULT_WITH_CSSVARS.border;
        }
    }
    console.error('Invalid colors type: ', colors, ' should be string or [string, string, string, string] or [string, string]');
    return DEFAULT_WITH_CSSVARS.border;
};
const isValidateArrayType = (arr, type) => {
    return Array.isArray(arr) && arr.every(item => typeof item === type);
};
const isValidate2DArrayType = (arr, type) => {
    return (Array.isArray(arr) &&
        arr.every(item => {
            return Array.isArray(item) && isValidateArrayType(item, type);
        }));
};
const getDashArray = (dashArrays, pos) => {
    if (dashArrays === undefined)
        return undefined;
    if (isValidateArrayType(dashArrays, 'number')) {
        return dashArrays.map(a => a.toString()).join(' ');
    }
    if (isValidate2DArrayType(dashArrays, 'number')) {
        const arr = dashArrays;
        const val = getValFromArr(arr, pos);
        if (val !== undefined)
            return val.map(a => a.toString()).join(' ');
    }
    console.error('Invalid dashArrays type: ', dashArrays, ' should be number[] or [number[], number[], number[], number[]] or [number[], number[]]');
    return undefined;
};
const validatedBorderShape = (borderShape, dashArrays) => {
    if (!dashArrays && !borderShape)
        return undefined;
    if (!dashArrays) {
        console.warn('border shape does not have any effect without dash arrays. automatically ignoring it.');
        return undefined;
    }
    if (!borderShape || borderShape === 'butt') {
        const dashArrs = dashArrays.split(' ');
        if (dashArrs.some((val, idx) => val === '0' && idx % 2 === 0)) {
            console.error('"butt" border shape(or undefined - default) will not be shown with 0 size. in odd order. i.e. stroke-dasharray="0 1" will not be shown since the first value is 0.', '\n\nyour dash array:', dashArrays);
        }
    }
    return borderShape;
};
const getBorderShape = (borderShapes, dashArrays, pos) => {
    if (!borderShapes)
        return validatedBorderShape(borderShapes, getDashArray(dashArrays, pos));
    if (typeof borderShapes === 'string')
        return validatedBorderShape(borderShapes, getDashArray(dashArrays, pos));
    if (Array.isArray(borderShapes)) {
        const val = getValFromArr(borderShapes, pos);
        if (val !== undefined) {
            return validatedBorderShape(val, getDashArray(dashArrays, pos));
        }
    }
    console.error('Invalid borderShapes type: ', borderShapes, ' should be string or [string, string, string, string] or [string, string]');
    return 'butt';
};
const isBorderRect = (style) => {
    const { borderWidths, borderColors, borderPatterns, bgColor, rx, ry } = style;
    if (!bgColor)
        return false;
    return ((!rx || typeof rx === 'number') &&
        (!ry || typeof ry === 'number') &&
        (!borderWidths || typeof borderWidths === 'number') &&
        (!borderColors || typeof borderColors === 'string') &&
        (!borderPatterns || (Array.isArray(borderPatterns) && typeof borderPatterns[0] === 'number')));
};
const getRectStyle = (style) => {
    if (!isBorderRect(style))
        return null;
    const { bgColor, borderWidths, borderColors, borderPatterns, rx, ry } = style;
    return {
        ...(bgColor ? { fill: bgColor } : {}),
        ...(rx || ry ? { rx: rx ?? 0, ry: ry ?? 0 } : {}),
        stroke: (borderColors ?? DEFAULT_WITH_CSSVARS.border),
        strokeWidth: borderWidths,
        strokeDasharray: getDashArray(borderPatterns, 'left'),
    };
};
const simpleValue = (val) => {
    return parseFloat(val.toFixed(2));
};
const camelToKebabCase = (str) => str.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`);
const kebabToCamelCase = (str) => str
    .split('-')
    .map((v, i) => (i === 0 ? v : v[0]?.toUpperCase() + v.substring(1)))
    .join('');
const getDuplicatedProps = (attr) => {
    Object.keys(attr).forEach(key => {
        attr[camelToKebabCase(key)] = attr[key];
    });
    Object.keys(attr).forEach(key => {
        attr[kebabToCamelCase(key)] = attr[key];
    });
};
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/element.js
const element_element = (type, attrs, ...children) => {
    const validChildren = children.filter(child => child !== undefined && child !== null);
    return Object.keys(attrs).length > 0 || validChildren.length > 0
        ? {
            __internal: 'svg-table-element-as-obj',
            type,
            attrs,
            children: validChildren.length > 0 && Array.isArray(validChildren[0]) ? validChildren[0] : validChildren,
        }
        : undefined;
};
//# sourceMappingURL=element.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/PathOnArea.js


const Path = ({ startPt, endPt, width, borderColors, borderPatterns, borderShapes, pos, className, }) => {
    if (width === 0)
        return null;
    return element_element('path', {
        className: className ? `${pos}-path` : undefined,
        d: `M${startPt} L${endPt}`,
        strokeWidth: width,
        stroke: getStrokeColor(borderColors, pos),
        strokeDasharray: getDashArray(borderPatterns, pos),
        strokeLinecap: getBorderShape(borderShapes, borderPatterns, pos),
    });
};
const getPt = (x, y) => `${x},${y}`;
const PathOnArea = (props) => {
    const { width, height, borderWidths, borderColors, borderPatterns, borderShapes, className, rx = 0, ry = 0, } = props;
    const PathProps = {
        borderColors,
        borderPatterns,
        borderShapes,
    };
    const cornerExist = rx && ry;
    const leftTop = getPt(0, 0);
    const leftBottom = getPt(0, height - 0);
    const rightTop = getPt(width - 0, 0);
    const rightBottom = getPt(width - 0, height - 0);
    if (cornerExist) {
        const width = (borderWidths && Array.isArray(borderWidths) ? borderWidths[0] : borderWidths) ?? 0;
        if (!width)
            return null;
        const leftLineTop = getPt(0, ry);
        const leftLineBottom = getPt(0, height - ry);
        const topLineLeft = getPt(rx, 0);
        const topLineRight = getPt(width - rx, 0);
        const rightLineTop = getPt(width, ry);
        const rightLineBottom = getPt(width, height - ry);
        const bottomLineLeft = getPt(rx, height);
        const bottomLineRight = getPt(width - rx, height);
        return element_element('g', {
            className: className ? `paths-on-area ${className}` : undefined,
        }, element_element('path', {
            className: className ? `${className}-corner-path` : undefined,
            d: `M${leftLineTop} Q${leftTop},${topLineLeft} L${topLineRight} Q${rightTop},${rightLineTop} L${rightLineBottom} Q${rightBottom},${bottomLineRight} L${bottomLineLeft} Q${leftBottom},${leftLineBottom} L${leftLineTop}`,
            strokeWidth: width,
            stroke: getStrokeColor(borderColors),
            strokeDasharray: getDashArray(borderPatterns),
            strokeLinecap: getBorderShape(borderShapes, borderPatterns),
        }));
    }
    else {
        const leftWid = getWid(borderWidths, 'left');
        const rightWid = getWid(borderWidths, 'right');
        const topWid = getWid(borderWidths, 'top');
        const bottomWid = getWid(borderWidths, 'bottom');
        return element_element('g', {
            className: className ? `paths-on-area ${className}` : undefined,
        }, !!leftWid &&
            Path({
                startPt: leftTop,
                endPt: leftBottom,
                width: leftWid,
                ...PathProps,
                pos: 'left',
            }), !!rightWid &&
            Path({
                startPt: rightTop,
                endPt: rightBottom,
                width: rightWid,
                ...PathProps,
                pos: 'right',
            }), !!topWid &&
            Path({
                startPt: leftTop,
                endPt: rightTop,
                width: topWid,
                ...PathProps,
                pos: 'top',
            }), !!bottomWid &&
            Path({
                startPt: leftBottom,
                endPt: rightBottom,
                width: bottomWid,
                ...PathProps,
                pos: 'bottom',
            }));
    }
};
//# sourceMappingURL=PathOnArea.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/FilledArea.js



const FilledArea = (props) => {
    const { bgColor, width, height, borderWidths, borderColors, borderPatterns, borderShapes, className, rx, ry } = props;
    const isBgColorVisible = bgColor && bgColor !== 'transparent';
    const isBorderOnRect = isBgColorVisible && isBorderRect(props);
    const rectStyleProps = isBorderOnRect ? getRectStyle(props) : { fill: bgColor };
    const isFilledAreaVisible = isBgColorVisible || getWidVisible(borderWidths);
    return isFilledAreaVisible
        ? element_element('g', {
            className: className ? `filled-area ${className ?? ''}` : undefined,
        }, isBgColorVisible &&
            element_element('rect', {
                width: width,
                height: height,
                ...rectStyleProps,
            }), !isBorderOnRect &&
            PathOnArea({
                className: className ? 'paths-on-area-for-filled-area' : undefined,
                width: width,
                height: height,
                borderWidths: borderWidths,
                borderColors: borderColors,
                borderPatterns: borderPatterns,
                borderShapes: borderShapes,
                rx,
                ry,
            }))
        : undefined;
};
/* harmony default export */ const dist_FilledArea = (FilledArea);
//# sourceMappingURL=FilledArea.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/CenteredCellContent.js


const CenteredCellContent = ({ cellOpt, styleToUse, children, }) => {
    let { width, height, className } = cellOpt;
    let { rotateCenterProps, cx = 0, cy = 0 } = styleToUse;
    const propsToPassForGroup = (startX, startY) => ({
        x: simpleValue(startX),
        y: simpleValue(startY),
        width,
        height,
    });
    const rotationGroupProps = {
        ...(typeof rotateCenterProps === 'function'
            ? rotateCenterProps(propsToPassForGroup(width / 2 + cx, height / 2 + cy))
            : rotateCenterProps),
    };
    getDuplicatedProps(rotationGroupProps);
    width = Math.max(width, 1);
    height = Math.max(height, 1);
    return element_element('svg', {
        viewBox: `${-width / 2} ${-height / 2} ${width} ${height}`,
        style: { overflow: 'visible' },
    }, element_element('g', {
        className: className ? `${className}-content` : undefined,
    }, element_element('g', rotationGroupProps, children)));
};
//# sourceMappingURL=CenteredCellContent.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/ACell.js





const moveToLeftTop = (width, height, content) => {
    return element_element('g', {
        transform: `translate(${-width / 2}, ${-height / 2})`,
    }, content);
};
const convertToTableIfNeeded = (contentTouse, width, height, paddings, cellOpt) => {
    if (contentTouse.table) {
        const padLeft = getWid(paddings, 'left');
        const padTop = getWid(paddings, 'top');
        const padRight = getWid(paddings, 'right');
        const padBottom = getWid(paddings, 'bottom');
        const tableWid = simpleValue(width - padRight - padLeft);
        const adjustProps = cellOpt._heightAdjust
            ? {
                height: simpleValue(Math.max(height - padTop - padBottom, 1)),
            }
            : {};
        if (cellOpt._standalone)
            adjustProps.standalone = true;
        return SVGTableBase({
            width: simpleValue(tableWid),
            ...adjustProps,
            ...contentTouse.table,
        });
    }
    return contentTouse;
};
const renderTextOnly = (contentToRender, startX, startY, textAnchor, styleToApply = {}) => {
    const lines = contentToRender.split('\n');
    let textToRender = [contentToRender];
    if (lines.length > 1) {
        const fontSize = styleToApply.fontSize || 16;
        textToRender = lines
            .filter(v => v)
            .map((line, index) => element_element('tspan', {
            fontSize,
            x: startX,
            dy: index === 0 ? 0 : fontSize,
        }, line));
        startY = startY - ((lines.length - 1) * simpleValue(fontSize)) / 2;
    }
    const props = {
        x: simpleValue(startX),
        y: simpleValue(startY),
        textAnchor: textAnchor,
        dominantBaseline: 'middle',
        ...styleToApply,
    };
    getDuplicatedProps(props);
    return element_element('text', props, ...textToRender);
};
const styleWithFill = (style, color) => {
    return {
        fill: color,
        ...style,
    };
};
const getAriaProps = (cellOpt) => {
    return JSON.parse(JSON.stringify({
        'aria-colspan': cellOpt.colSpan && cellOpt.colSpan > 1 ? cellOpt.colSpan : undefined,
        'aria-rowspan': cellOpt.rowSpan && cellOpt.rowSpan > 1 ? cellOpt.rowSpan : undefined,
    }));
};
const getContents = (cellOpt, styleToUse) => {
    const { content, width, height, before, after } = cellOpt;
    let { paddings, textColor, textStyle, cx = 0, cy = 0 } = styleToUse;
    textStyle = styleWithFill(textStyle, textColor);
    const { content: before2, ...beforeOpts } = typeof before === 'object' && before.content
        ? before
        : { content: before };
    const { content: after2, ...afterOpts } = typeof after === 'object' && after.content
        ? after
        : { content: after };
    const beforeTextStyle = styleWithFill(beforeOpts.textStyle, textColor);
    const afterTextStyle = styleWithFill(afterOpts.textStyle, textColor);
    const propsToPass = (textStyleToUse, anchorBase, startX, startY) => ({
        x: simpleValue(startX),
        y: simpleValue(startY),
        width,
        height,
        textColor,
        textStyle: {
            textAnchor: anchorBase,
            dominantBaseline: 'middle',
            ...textStyleToUse,
        },
    });
    const getContent = () => {
        if (typeof content === 'function') {
            let node = content(propsToPass(textStyle, 'middle', width / 2 + cx, height / 2 + cy));
            return node;
        }
        else if (typeof content === 'object') {
            const node = convertToTableIfNeeded(content, width, height, paddings, cellOpt);
            return node;
        }
        else {
            return content;
        }
    };
    const contentToUse = getContent();
    let beforeToUse = typeof before2 === 'function' ? before2(propsToPass(beforeTextStyle, 'start', 0, height / 2)) : before2;
    let afterToUse = typeof after2 === 'function' ? after2(propsToPass(afterTextStyle, 'end', width, height / 2)) : after2;
    const beforeContent = beforeToUse && typeof beforeToUse === 'string'
        ? renderTextOnly(beforeToUse, 0, height / 2, 'start', beforeTextStyle)
        : beforeToUse;
    const afterContent = afterToUse && typeof afterToUse === 'string'
        ? renderTextOnly(afterToUse, width, height / 2, 'end', afterTextStyle)
        : afterToUse;
    const mainContent = typeof contentToUse === 'string'
        ? renderTextOnly(contentToUse, cx, cy, 'middle', textStyle)
        : moveToLeftTop(width, height, contentToUse);
    return {
        beforeContent,
        afterContent,
        mainContent,
    };
};
const FilledAreaInCell = ({ cellOpt, styleToUse, }) => {
    const { width, height, className } = cellOpt;
    let { bgColor, borderWidths, borderColors, borderPatterns, borderShapes, rx, ry } = styleToUse;
    return dist_FilledArea({
        className: className ? `${className}-filled-back` : undefined,
        width: width,
        height: height,
        borderWidths: borderWidths,
        borderColors: borderColors,
        borderPatterns: borderPatterns,
        borderShapes: borderShapes,
        rx,
        ry,
        ...(bgColor ? { bgColor } : {}),
    });
};
const ACell = ({ cellOpt, defaultStyle, }) => {
    if (cellOpt._ignored)
        return null;
    let { x, y, width, height, style, className } = cellOpt;
    const styleToUse = {
        ...defaultStyle,
        ...style,
    };
    let { paddings, svgStyle, allowOverflow } = styleToUse;
    const padLeft = getWid(paddings, 'left');
    const padTop = getWid(paddings, 'top');
    const svgStyleToUse = {
        ...svgStyle,
        ...(allowOverflow ? { overflow: 'visible' } : {}),
    };
    const ariaProps = getAriaProps(cellOpt);
    const { beforeContent, afterContent, mainContent } = getContents(cellOpt, styleToUse);
    width = Math.max(width, 1);
    height = Math.max(height, 1);
    return element_element('g', {
        transform: `translate(${x}, ${y})`,
        className: className ? `${className}-wrapper` : undefined,
    }, FilledAreaInCell({ cellOpt: cellOpt, styleToUse: styleToUse }), element_element('svg', {
        width: width,
        height: height,
        style: svgStyleToUse,
        viewBox: `0 0 ${width} ${height}`,
        className: className ? className : undefined,
    }, element_element('g', {
        transform: `translate(${padLeft}, ${padTop})`,
        className: className ? `${className}-padding` : undefined,
        role: 'cell',
        ...ariaProps,
    }, beforeContent, CenteredCellContent({
        cellOpt: cellOpt,
        styleToUse: styleToUse,
        children: mainContent,
    }), afterContent)));
};
//# sourceMappingURL=ACell.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/calculateRows.js

let debugObj = {};
const getCellWidth = (cellWidths, startCol, colSpan, colGap) => {
    if (cellWidths.length < startCol + colSpan - 1) {
        console.error('Not enough column widths provided. check colSpan of the cell data. startCol: ' + startCol, 'data is:', JSON.parse(JSON.stringify(debugObj)));
    }
    return simpleValue(cellWidths.slice(startCol, startCol + colSpan).reduce((total, width) => total + width, 0) +
        colGap * (colSpan - 1));
};
const getCellHeight = (rowHeights, startRow, rowSpan, rowGap) => {
    if (rowHeights.length < startRow + rowSpan - 1) {
        console.error('Not enough row heights provided. check rowSpan of the cell data. startRow: ' + startRow, 'data is:', JSON.parse(JSON.stringify(debugObj)));
    }
    return (rowHeights.slice(startRow, startRow + rowSpan).reduce((total, height) => total + height, 0) +
        rowGap * (rowSpan - 1));
};
const insertIgnoredCell = (row, colIndex, cell) => {
    row.cells = [
        ...(row.cells.slice(0, colIndex) ?? []),
        ...Array(cell.colSpan ?? 1)
            .fill(null)
            .map(() => ({
            _ignored: true,
            colSpan: 1,
        })),
        ...(row.cells.slice(colIndex) ?? []),
    ];
};
const calculateRows = (cellWidths, rowHeights, rows, style, tableProps) => {
    let currentY = 0;
    const embededTableHeightAdjust = !!tableProps.height;
    const standaloneTable = !!tableProps.standalone;
    const calcRows = rows.map(aRow => {
        const row = Array.isArray(aRow) ? { cells: aRow } : aRow;
        return {
            ...row,
            x: 0,
            y: currentY,
            height: -1,
            width: -1,
            cells: [
                ...row.cells.map(aCell => {
                    const cell = typeof aCell === 'string' ? { content: aCell } : aCell;
                    return {
                        ...cell,
                        x: -1,
                        y: -1,
                        height: -1,
                        width: -1,
                        _ignored: false,
                        _heightAdjust: embededTableHeightAdjust,
                        _standalone: standaloneTable,
                    };
                }),
            ],
        };
    });
    for (let ri = 0; ri < calcRows.length; ri++) {
        const row = calcRows[ri];
        if (!row)
            continue;
        let currentX = 0;
        let idx = 0;
        for (const cell of row.cells) {
            debugObj = {
                row: row,
                cell: cell,
            };
            if (cell._ignored) {
                const widToSkip = getCellWidth(cellWidths, idx, 1, style?.colGaps ?? 0);
                idx += 1;
                currentX += widToSkip + (style?.colGaps ?? 0);
                continue;
            }
            const isLastCellButNotLastColumn = row.cells[row.cells.length - 1] === cell && idx !== cellWidths.length - 1;
            const colSpan = isLastCellButNotLastColumn ? cellWidths.length - idx : 1;
            cell.colSpan = colSpan;
            const cellWidth = getCellWidth(cellWidths, idx, cell.colSpan, style?.colGaps ?? 0);
            if (cell.rowSpan) {
                for (let i = 1; i < cell.rowSpan; i++) {
                    if (calcRows[ri + i]) {
                        insertIgnoredCell(calcRows[ri + i], idx, cell);
                    }
                    else {
                        console.error('row is not found at index: ' + (idx + i), 'your cell is:', cell, 'your rows are', calcRows, 'idx is', idx);
                    }
                }
            }
            cell.width = cellWidth;
            cell.height = getCellHeight(rowHeights, ri, cell.rowSpan ?? 1, style?.rowGaps ?? 0);
            cell.x = simpleValue(currentX);
            cell.y = simpleValue(currentY);
            currentX += cellWidth + (style?.colGaps ?? 0);
            idx += 1;
        }
        currentY += (rowHeights[ri] ?? 0) + (style?.rowGaps ?? 0);
        row.height = currentY;
        row.width = currentX;
    }
    return calcRows;
};
//# sourceMappingURL=calculateRows.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/SVGTableBase.js






const getTotalCells = (cells) => {
    return cells.reduce((total, cell) => {
        const cellAsObj = cell;
        if (typeof cellAsObj === 'object' && cellAsObj.colSpan) {
            return total + cellAsObj.colSpan;
        }
        return total + 1;
    }, 0);
};
const parsedTableStyle = (style) => {
    return {
        rowGaps: 0,
        colGaps: 0,
        borderWidths: undefined,
        borderPatterns: undefined,
        borderShapes: undefined,
        borderColors: style?.borderWidths ? `var(${INTERNAL_CSS_VARS.borderLineColor}, #000)` : undefined,
        svgStyle: { overflow: 'visible' },
        ...style,
        margins: style?.margins ?? 0,
    };
};
const parseDefaultCellStyleBase = (defaultCellStyleBase) => {
    return {
        allowOverflow: false,
        borderWidths: 1,
        bgColor: undefined,
        textStyle: undefined,
        borderColors: `var(${INTERNAL_CSS_VARS.borderLineColor}, #000)`,
        borderPatterns: undefined,
        borderShapes: undefined,
        paddings: [1, 1, 1, 1],
        textColor: `var(${INTERNAL_CSS_VARS.textColor}, #000)`,
        ...defaultCellStyleBase,
        onlyInnerBorders: defaultCellStyleBase?.rx && defaultCellStyleBase?.ry
            ? true
            : (defaultCellStyleBase?.onlyInnerBorders ?? false),
    };
};
const adjustColumnWidths = (columnWidths, tableWidthWithoutGaps) => {
    const totalWidth = columnWidths.reduce((total, width) => total + width, 0);
    const ratio = tableWidthWithoutGaps / totalWidth;
    if (ratio > 0.99 && ratio <= 1.01)
        return columnWidths;
    return columnWidths.map(width => Math.max(simpleValue(width * ratio), 1));
};
const adjustRowHeights = (rowHeights, tableHeightWithoutGaps) => {
    const totalHeight = rowHeights.reduce((total, width) => total + width, 0);
    const ratio = tableHeightWithoutGaps / totalHeight;
    if (ratio > 0.99 && ratio <= 1.01)
        return rowHeights;
    return rowHeights.map(width => Math.max(simpleValue(width * ratio), 1));
};
let maskIdSrc = 0;
const SVGTableBase = (tablePropsWithStandalone) => {
    const { standalone = false, ...tableProps } = tablePropsWithStandalone;
    let { rows, width = 500, height: heightFromProps, defaultCellStyle, defaultRowStyle, columnWidths, rowHeights: rowHeightFromProps, style, className, defs, svgAttrs, } = tableProps;
    const defaultStyleForCell = parseDefaultCellStyleBase(defaultCellStyle);
    const maxColumns = Math.max(rows.reduce((max, row) => Array.isArray(row) ? Math.max(max, row.length) : Math.max(max, getTotalCells(row.cells)), 0), 1);
    const tableStyle = parsedTableStyle(style);
    const isRoundedCorner = !!(tableStyle.rx && tableStyle.ry);
    const allColGaps = (maxColumns - 1) * tableStyle.colGaps +
        getWid(tableStyle.margins, 'left') +
        getWid(tableStyle.margins, 'right');
    const allRowGaps = (rows.length - 1) * tableStyle.rowGaps +
        getWid(tableStyle.margins, 'top') +
        getWid(tableStyle.margins, 'bottom');
    const defaultStyleForRow = {
        height: 30,
        ...defaultRowStyle,
    };
    let height = heightFromProps ??
        rows.reduce((h, row) => {
            if (Array.isArray(row)) {
                return h + defaultStyleForRow.height;
            }
            return h + (row.style?.height ?? defaultStyleForRow.height);
        }, 0) + allRowGaps;
    height = Math.max(simpleValue(height), 1);
    width = Math.max(simpleValue(width), 1);
    const cellWidths = columnWidths
        ? adjustColumnWidths(columnWidths, width - allColGaps)
        : Array(maxColumns).fill(simpleValue((width - allColGaps) / maxColumns));
    let rowHeights = rowHeightFromProps ??
        rows.map(row => row.style?.height ?? defaultStyleForRow.height);
    if (heightFromProps) {
        rowHeights = adjustRowHeights(rowHeights, heightFromProps - allRowGaps);
        for (let i = 0; i < rows.length; i++) {
            const rowHeightFromRowStyle = rows[i]?.style?.height;
            if (rowHeightFromRowStyle && typeof rowHeights[i] === 'number') {
                rowHeights[i] = rowHeightFromRowStyle;
            }
        }
    }
    const calculatedRows = calculateRows(cellWidths, rowHeights, rows, tableStyle, tableProps);
    const rowsContent = calculatedRows.map((row, rowIndex) => {
        const rowContent = [];
        if (row.style?.bgColor) {
            rowContent.push(element_element('g', {
                transform: `translate(${row.x}, ${row.y})`,
                className: className ? `${className}-row-${rowIndex}-wrapper` : undefined,
            }, dist_FilledArea({
                className: className ? `${className}-filled-area-behind-table` : undefined,
                width: row.width,
                height: row.height,
                bgColor: row.style.bgColor,
                borderWidths: row.style.borderWidths,
                borderColors: row.style.borderColors,
                borderPatterns: row.style.borderPatterns,
                borderShapes: row.style.borderShapes,
                rx: row.style.rx,
                ry: row.style.ry,
            })));
        }
        for (const cell of row.cells) {
            rowContent.push(ACell({
                cellOpt: cell,
                defaultStyle: defaultStyleForCell,
            }));
        }
        return element_element('g', {
            role: 'row',
            className: className ? `${className}-row-${rowIndex}` : undefined,
        }, ...rowContent);
    });
    const propsForSvg = standalone
        ? {
            xmlns: 'http://www.w3.org/2000/svg',
            xmlnsXlink: 'http://www.w3.org/1999/xlink',
        }
        : {
            width,
            height,
        };
    const maskName = `svg-table-mask-${className}-${maskIdSrc++ % 10000000}`;
    return element_element('svg', {
        ...propsForSvg,
        viewBox: `0 0 ${width} ${height}`,
        xmlns: 'http://www.w3.org/2000/svg',
        className: className ? `svg-table ${className}` : undefined,
        ...svgAttrs,
        style: { overflow: 'visible' },
    }, defs && element_element('defs', {}, defs), isRoundedCorner &&
        element_element('mask', {
            id: maskName,
        }, [
            element_element('rect', {
                width: width,
                height: height,
                fill: 'black',
            }),
            element_element('rect', {
                width: width,
                height: height,
                rx: tableStyle.rx,
                ry: tableStyle.ry,
                fill: 'white',
            }),
        ]), dist_FilledArea({
        className: className ? `${className}-filled-area-behind-table` : undefined,
        width: width,
        height: height,
        bgColor: tableStyle.bgColor,
        borderWidths: tableStyle.borderWidths,
        borderColors: tableStyle.borderColors,
        borderPatterns: tableStyle.borderPatterns,
        borderShapes: tableStyle.borderShapes,
        rx: tableStyle.rx,
        ry: tableStyle.ry,
    }), element_element('g', {
        role: 'table',
        className: className ? `${className}-content-area` : undefined,
        transform: `translate(${getWid(tableStyle.margins, 'left')} ${getWid(tableStyle.margins, 'top')})`,
        ...(isRoundedCorner ? { mask: `url(#${maskName})` } : {}),
    }, ...rowsContent));
};
//# sourceMappingURL=SVGTableBase.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/index.js






//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-vanilla/dist/utils.js
const kebabize = (str) => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());
const convertVal = (val, key) => {
    if (typeof val !== 'number' && !val)
        return '';
    if (typeof val === 'object') {
        if (Array.isArray(val)) {
            console.error('something is wrong.. value type cannot be array', 'key:', key, 'val:', val);
            return '';
        }
        return Object.entries(val)
            .map(([k, v]) => {
            return `${kebabize(k)}:${v}`;
        })
            .join(';');
    }
    return `${val}`;
};
const convertAttrToHtmlStyle = (attrName) => {
    if (attrName === 'className')
        return 'class';
    switch (attrName) {
        case 'viewBox':
            return attrName;
    }
    if (attrName.match(/[A-Z]+/)) {
        const newKey = kebabize(attrName);
        return newKey;
    }
    return attrName;
};
const convertToKebabCaseProps = (attrs) => {
    const kebabCaseProps = Object.keys(attrs).reduce((curr, key) => {
        const convertedKey = convertAttrToHtmlStyle(key);
        const converted = `${convertVal(attrs[key], key)}`;
        if (!converted)
            return curr;
        return { ...curr, [convertedKey]: converted };
    }, {});
    return kebabCaseProps;
};
const createVanillaElement = (type, attrs, ...children) => {
    return {
        __internal: 'svg-table-element-as-obj',
        type,
        attrs,
        children,
    };
};
const createRenderedString = (...renderedHtml) => {
    return {
        __internal: 'svg-table-rendered-text',
        type: 'g',
        attrs: {},
        children: [renderedHtml.join('')],
    };
};
const __private__ = {
    convertVal,
    convertAttrToHtmlStyle,
};
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-vanilla/dist/svgConverter.js

const svgConverter = (element) => {
    if (element === null || element === undefined)
        return '';
    if (typeof element === 'string')
        return element;
    if (Array.isArray(element)) {
        return element.map(c => svgConverter(c)).join('\n');
    }
    if (typeof element !== 'object') {
        if (typeof element !== 'number' && !element)
            return '';
        return svgConverter(element);
    }
    const el = element;
    if (el.type && el.attrs && el.__internal === 'svg-table-element-as-obj') {
        const children = typeof el.children === 'string'
            ? el.children
            : el.children
                ? el.children
                    .map(c => (typeof c === 'boolean' && !c ? null : svgConverter(c)))
                    .filter(v => v)
                    .join('\n')
                : '';
        const kebabCaseProps = convertToKebabCaseProps(el.attrs);
        const attrs = Object.entries(kebabCaseProps)
            .map(entry => {
            const [key, val] = entry;
            return `${key}="${val}"`;
        })
            .filter(v => v)
            .join(' ');
        return `<${el.type} ${attrs}>${children}</${el.type}>`;
    }
    if (el.__internal === 'svg-table-rendered-text') {
        const children = typeof el.children === 'string' ? el.children : el.children ? el.children.filter(v => v).join('\n') : '';
        return children;
    }
    return element.outerHTML;
};
//# sourceMappingURL=svgConverter.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-vanilla/dist/SVGTable.js


const SVGTable = (tableProps) => {
    const element = SVGTableBase(tableProps);
    return svgConverter(element);
};
//# sourceMappingURL=SVGTable.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-vanilla/dist/index.js




/* harmony default export */ const dist = (SVGTable);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./index.ts
// @ts-ignore

// @ts-ignore


SVGTableVanilla = __webpack_exports__;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxJQUFJLElBQUk7QUFDbEMsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUyxFQUFFLE1BQU0sR0FBRyxTQUFTLElBQUksUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDMEQ7QUFDWjtBQUN2QztBQUNQLG9CQUFvQixZQUFZO0FBQ2hDLFdBQVcsWUFBWTtBQUN2QjtBQUNBOztBQ05zQztBQUNkO0FBQ2lDO0FBQ2pDO0FBQ3hCLDJDQUFlLFFBQVEsRUFBQztBQUN4Qjs7QUNMQTtBQUM4QztBQUM5QztBQUN3RCIsInNvdXJjZXMiOlsid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNoamVvbjA3MzAvc3ZnLXRhYmxlLWNvcmUvZGlzdC9jb25zdHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac2hqZW9uMDczMC9zdmctdGFibGUtY29yZS9kaXN0L3V0aWxzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNoamVvbjA3MzAvc3ZnLXRhYmxlLWNvcmUvZGlzdC9lbGVtZW50LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNoamVvbjA3MzAvc3ZnLXRhYmxlLWNvcmUvZGlzdC9QYXRoT25BcmVhLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNoamVvbjA3MzAvc3ZnLXRhYmxlLWNvcmUvZGlzdC9GaWxsZWRBcmVhLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNoamVvbjA3MzAvc3ZnLXRhYmxlLWNvcmUvZGlzdC9DZW50ZXJlZENlbGxDb250ZW50LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNoamVvbjA3MzAvc3ZnLXRhYmxlLWNvcmUvZGlzdC9BQ2VsbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BzaGplb24wNzMwL3N2Zy10YWJsZS1jb3JlL2Rpc3QvY2FsY3VsYXRlUm93cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BzaGplb24wNzMwL3N2Zy10YWJsZS1jb3JlL2Rpc3QvU1ZHVGFibGVCYXNlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNoamVvbjA3MzAvc3ZnLXRhYmxlLWNvcmUvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BzaGplb24wNzMwL3N2Zy10YWJsZS12YW5pbGxhL2Rpc3QvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac2hqZW9uMDczMC9zdmctdGFibGUtdmFuaWxsYS9kaXN0L3N2Z0NvbnZlcnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BzaGplb24wNzMwL3N2Zy10YWJsZS12YW5pbGxhL2Rpc3QvU1ZHVGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac2hqZW9uMDczMC9zdmctdGFibGUtdmFuaWxsYS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoZSByZXF1aXJlIHNjb3BlXG52YXIgX193ZWJwYWNrX3JlcXVpcmVfXyA9IHt9O1xuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiZXhwb3J0IGNvbnN0IElOVEVSTkFMX0NTU19WQVJTID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgYm9yZGVyTGluZUNvbG9yOiAnLS1saW5lLWRlZmF1bHQtc3Ryb2tlJyxcbiAgICB0ZXh0Q29sb3I6ICctLXRleHQtZGVmYXVsdC1jb2xvcicsXG59KTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX0NPTE9SUyA9IE9iamVjdC5mcmVlemUoe1xuICAgIGJvcmRlcjogJyMwMDAnLFxufSk7XG5leHBvcnQgY29uc3QgREVGQVVMVF9XSVRIX0NTU1ZBUlMgPSBPYmplY3QuZnJlZXplKHtcbiAgICBib3JkZXI6IGB2YXIoJHtJTlRFUk5BTF9DU1NfVkFSUy5ib3JkZXJMaW5lQ29sb3J9LCAke0RFRkFVTFRfQ09MT1JTLmJvcmRlcn0pYCxcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RzLmpzLm1hcCIsImltcG9ydCB7IERFRkFVTFRfV0lUSF9DU1NWQVJTIH0gZnJvbSAnLi9jb25zdHMnO1xuY29uc3QgZ2V0VmFsRnJvbUFyciA9IChhcnIsIHBvcykgPT4ge1xuICAgIGlmIChhcnIubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHN3aXRjaCAocG9zKSB7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyWzNdO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJbMV07XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJbMl07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyci5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJbMV07XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyclsxXTtcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbn07XG5leHBvcnQgY29uc3QgZ2V0V2lkID0gKHdpZHRocywgcG9zKSA9PiB7XG4gICAgaWYgKHdpZHRocyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBpZiAodHlwZW9mIHdpZHRocyA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiB3aWR0aHM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkod2lkdGhzKSkge1xuICAgICAgICBjb25zdCB2YWwgPSBnZXRWYWxGcm9tQXJyKHdpZHRocywgcG9zKTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcignSW52YWxpZCB3aWR0aHMgdHlwZTogJywgd2lkdGhzLCAnZm9yJywgcG9zLCAnIHNob3VsZCBiZSBudW1iZXIgb3IgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gb3IgW251bWJlciwgbnVtYmVyXScpO1xuICAgIHJldHVybiAwO1xufTtcbmV4cG9ydCBjb25zdCBnZXRXaWRWaXNpYmxlID0gKHdpZHRocykgPT4ge1xuICAgIGlmICh3aWR0aHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2Ygd2lkdGhzID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIHdpZHRocyA+IDA7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkod2lkdGhzKSkge1xuICAgICAgICByZXR1cm4gd2lkdGhzLnNvbWUodyA9PiB3ID4gMCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5leHBvcnQgY29uc3QgZ2V0U3Ryb2tlQ29sb3IgPSAoY29sb3JzLCBwb3MpID0+IHtcbiAgICBpZiAoIWNvbG9ycylcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIGNvbG9ycyA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBjb2xvcnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3JzKSkge1xuICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBnZXRWYWxGcm9tQXJyKGNvbG9ycywgcG9zKTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChjb2xvcnMgJiYgQXJyYXkuaXNBcnJheShjb2xvcnMpID8gY29sb3JzWzBdIDogY29sb3JzKSA/PyBERUZBVUxUX1dJVEhfQ1NTVkFSUy5ib3JkZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5lcnJvcignSW52YWxpZCBjb2xvcnMgdHlwZTogJywgY29sb3JzLCAnIHNob3VsZCBiZSBzdHJpbmcgb3IgW3N0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZ10gb3IgW3N0cmluZywgc3RyaW5nXScpO1xuICAgIHJldHVybiBERUZBVUxUX1dJVEhfQ1NTVkFSUy5ib3JkZXI7XG59O1xuZXhwb3J0IGNvbnN0IGlzVmFsaWRhdGVBcnJheVR5cGUgPSAoYXJyLCB0eXBlKSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKSAmJiBhcnIuZXZlcnkoaXRlbSA9PiB0eXBlb2YgaXRlbSA9PT0gdHlwZSk7XG59O1xuZXhwb3J0IGNvbnN0IGlzVmFsaWRhdGUyREFycmF5VHlwZSA9IChhcnIsIHR5cGUpID0+IHtcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkoYXJyKSAmJlxuICAgICAgICBhcnIuZXZlcnkoaXRlbSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShpdGVtKSAmJiBpc1ZhbGlkYXRlQXJyYXlUeXBlKGl0ZW0sIHR5cGUpO1xuICAgICAgICB9KSk7XG59O1xuZXhwb3J0IGNvbnN0IGdldERhc2hBcnJheSA9IChkYXNoQXJyYXlzLCBwb3MpID0+IHtcbiAgICBpZiAoZGFzaEFycmF5cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmIChpc1ZhbGlkYXRlQXJyYXlUeXBlKGRhc2hBcnJheXMsICdudW1iZXInKSkge1xuICAgICAgICByZXR1cm4gZGFzaEFycmF5cy5tYXAoYSA9PiBhLnRvU3RyaW5nKCkpLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgaWYgKGlzVmFsaWRhdGUyREFycmF5VHlwZShkYXNoQXJyYXlzLCAnbnVtYmVyJykpIHtcbiAgICAgICAgY29uc3QgYXJyID0gZGFzaEFycmF5cztcbiAgICAgICAgY29uc3QgdmFsID0gZ2V0VmFsRnJvbUFycihhcnIsIHBvcyk7XG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB2YWwubWFwKGEgPT4gYS50b1N0cmluZygpKS5qb2luKCcgJyk7XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgZGFzaEFycmF5cyB0eXBlOiAnLCBkYXNoQXJyYXlzLCAnIHNob3VsZCBiZSBudW1iZXJbXSBvciBbbnVtYmVyW10sIG51bWJlcltdLCBudW1iZXJbXSwgbnVtYmVyW11dIG9yIFtudW1iZXJbXSwgbnVtYmVyW11dJyk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5jb25zdCB2YWxpZGF0ZWRCb3JkZXJTaGFwZSA9IChib3JkZXJTaGFwZSwgZGFzaEFycmF5cykgPT4ge1xuICAgIGlmICghZGFzaEFycmF5cyAmJiAhYm9yZGVyU2hhcGUpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKCFkYXNoQXJyYXlzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYm9yZGVyIHNoYXBlIGRvZXMgbm90IGhhdmUgYW55IGVmZmVjdCB3aXRob3V0IGRhc2ggYXJyYXlzLiBhdXRvbWF0aWNhbGx5IGlnbm9yaW5nIGl0LicpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIWJvcmRlclNoYXBlIHx8IGJvcmRlclNoYXBlID09PSAnYnV0dCcpIHtcbiAgICAgICAgY29uc3QgZGFzaEFycnMgPSBkYXNoQXJyYXlzLnNwbGl0KCcgJyk7XG4gICAgICAgIGlmIChkYXNoQXJycy5zb21lKCh2YWwsIGlkeCkgPT4gdmFsID09PSAnMCcgJiYgaWR4ICUgMiA9PT0gMCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1wiYnV0dFwiIGJvcmRlciBzaGFwZShvciB1bmRlZmluZWQgLSBkZWZhdWx0KSB3aWxsIG5vdCBiZSBzaG93biB3aXRoIDAgc2l6ZS4gaW4gb2RkIG9yZGVyLiBpLmUuIHN0cm9rZS1kYXNoYXJyYXk9XCIwIDFcIiB3aWxsIG5vdCBiZSBzaG93biBzaW5jZSB0aGUgZmlyc3QgdmFsdWUgaXMgMC4nLCAnXFxuXFxueW91ciBkYXNoIGFycmF5OicsIGRhc2hBcnJheXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3JkZXJTaGFwZTtcbn07XG5leHBvcnQgY29uc3QgZ2V0Qm9yZGVyU2hhcGUgPSAoYm9yZGVyU2hhcGVzLCBkYXNoQXJyYXlzLCBwb3MpID0+IHtcbiAgICBpZiAoIWJvcmRlclNoYXBlcylcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEJvcmRlclNoYXBlKGJvcmRlclNoYXBlcywgZ2V0RGFzaEFycmF5KGRhc2hBcnJheXMsIHBvcykpO1xuICAgIGlmICh0eXBlb2YgYm9yZGVyU2hhcGVzID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEJvcmRlclNoYXBlKGJvcmRlclNoYXBlcywgZ2V0RGFzaEFycmF5KGRhc2hBcnJheXMsIHBvcykpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJvcmRlclNoYXBlcykpIHtcbiAgICAgICAgY29uc3QgdmFsID0gZ2V0VmFsRnJvbUFycihib3JkZXJTaGFwZXMsIHBvcyk7XG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEJvcmRlclNoYXBlKHZhbCwgZ2V0RGFzaEFycmF5KGRhc2hBcnJheXMsIHBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgYm9yZGVyU2hhcGVzIHR5cGU6ICcsIGJvcmRlclNoYXBlcywgJyBzaG91bGQgYmUgc3RyaW5nIG9yIFtzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmddIG9yIFtzdHJpbmcsIHN0cmluZ10nKTtcbiAgICByZXR1cm4gJ2J1dHQnO1xufTtcbmV4cG9ydCBjb25zdCBpc0JvcmRlclJlY3QgPSAoc3R5bGUpID0+IHtcbiAgICBjb25zdCB7IGJvcmRlcldpZHRocywgYm9yZGVyQ29sb3JzLCBib3JkZXJQYXR0ZXJucywgYmdDb2xvciwgcngsIHJ5IH0gPSBzdHlsZTtcbiAgICBpZiAoIWJnQ29sb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKCghcnggfHwgdHlwZW9mIHJ4ID09PSAnbnVtYmVyJykgJiZcbiAgICAgICAgKCFyeSB8fCB0eXBlb2YgcnkgPT09ICdudW1iZXInKSAmJlxuICAgICAgICAoIWJvcmRlcldpZHRocyB8fCB0eXBlb2YgYm9yZGVyV2lkdGhzID09PSAnbnVtYmVyJykgJiZcbiAgICAgICAgKCFib3JkZXJDb2xvcnMgfHwgdHlwZW9mIGJvcmRlckNvbG9ycyA9PT0gJ3N0cmluZycpICYmXG4gICAgICAgICghYm9yZGVyUGF0dGVybnMgfHwgKEFycmF5LmlzQXJyYXkoYm9yZGVyUGF0dGVybnMpICYmIHR5cGVvZiBib3JkZXJQYXR0ZXJuc1swXSA9PT0gJ251bWJlcicpKSk7XG59O1xuZXhwb3J0IGNvbnN0IGdldFJlY3RTdHlsZSA9IChzdHlsZSkgPT4ge1xuICAgIGlmICghaXNCb3JkZXJSZWN0KHN0eWxlKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgeyBiZ0NvbG9yLCBib3JkZXJXaWR0aHMsIGJvcmRlckNvbG9ycywgYm9yZGVyUGF0dGVybnMsIHJ4LCByeSB9ID0gc3R5bGU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uKGJnQ29sb3IgPyB7IGZpbGw6IGJnQ29sb3IgfSA6IHt9KSxcbiAgICAgICAgLi4uKHJ4IHx8IHJ5ID8geyByeDogcnggPz8gMCwgcnk6IHJ5ID8/IDAgfSA6IHt9KSxcbiAgICAgICAgc3Ryb2tlOiAoYm9yZGVyQ29sb3JzID8/IERFRkFVTFRfV0lUSF9DU1NWQVJTLmJvcmRlciksXG4gICAgICAgIHN0cm9rZVdpZHRoOiBib3JkZXJXaWR0aHMsXG4gICAgICAgIHN0cm9rZURhc2hhcnJheTogZ2V0RGFzaEFycmF5KGJvcmRlclBhdHRlcm5zLCAnbGVmdCcpLFxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IHNpbXBsZVZhbHVlID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbC50b0ZpeGVkKDIpKTtcbn07XG5leHBvcnQgY29uc3QgY2FtZWxUb0tlYmFiQ2FzZSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC9bQS1aXS9nLCBsZXR0ZXIgPT4gYC0ke2xldHRlci50b0xvd2VyQ2FzZSgpfWApO1xuZXhwb3J0IGNvbnN0IGtlYmFiVG9DYW1lbENhc2UgPSAoc3RyKSA9PiBzdHJcbiAgICAuc3BsaXQoJy0nKVxuICAgIC5tYXAoKHYsIGkpID0+IChpID09PSAwID8gdiA6IHZbMF0/LnRvVXBwZXJDYXNlKCkgKyB2LnN1YnN0cmluZygxKSkpXG4gICAgLmpvaW4oJycpO1xuZXhwb3J0IGNvbnN0IGdldER1cGxpY2F0ZWRQcm9wcyA9IChhdHRyKSA9PiB7XG4gICAgT2JqZWN0LmtleXMoYXR0cikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBhdHRyW2NhbWVsVG9LZWJhYkNhc2Uoa2V5KV0gPSBhdHRyW2tleV07XG4gICAgfSk7XG4gICAgT2JqZWN0LmtleXMoYXR0cikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBhdHRyW2tlYmFiVG9DYW1lbENhc2Uoa2V5KV0gPSBhdHRyW2tleV07XG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiZXhwb3J0IGNvbnN0IGVsZW1lbnQgPSAodHlwZSwgYXR0cnMsIC4uLmNoaWxkcmVuKSA9PiB7XG4gICAgY29uc3QgdmFsaWRDaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiBjaGlsZCAhPT0gdW5kZWZpbmVkICYmIGNoaWxkICE9PSBudWxsKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aCA+IDAgfHwgdmFsaWRDaGlsZHJlbi5sZW5ndGggPiAwXG4gICAgICAgID8ge1xuICAgICAgICAgICAgX19pbnRlcm5hbDogJ3N2Zy10YWJsZS1lbGVtZW50LWFzLW9iaicsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgICBjaGlsZHJlbjogdmFsaWRDaGlsZHJlbi5sZW5ndGggPiAwICYmIEFycmF5LmlzQXJyYXkodmFsaWRDaGlsZHJlblswXSkgPyB2YWxpZENoaWxkcmVuWzBdIDogdmFsaWRDaGlsZHJlbixcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGVtZW50LmpzLm1hcCIsImltcG9ydCB7IGVsZW1lbnQgfSBmcm9tICcuL2VsZW1lbnQnO1xuaW1wb3J0IHsgZ2V0Qm9yZGVyU2hhcGUsIGdldFN0cm9rZUNvbG9yLCBnZXREYXNoQXJyYXksIGdldFdpZCB9IGZyb20gJy4vdXRpbHMnO1xuY29uc3QgUGF0aCA9ICh7IHN0YXJ0UHQsIGVuZFB0LCB3aWR0aCwgYm9yZGVyQ29sb3JzLCBib3JkZXJQYXR0ZXJucywgYm9yZGVyU2hhcGVzLCBwb3MsIGNsYXNzTmFtZSwgfSkgPT4ge1xuICAgIGlmICh3aWR0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGVsZW1lbnQoJ3BhdGgnLCB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYCR7cG9zfS1wYXRoYCA6IHVuZGVmaW5lZCxcbiAgICAgICAgZDogYE0ke3N0YXJ0UHR9IEwke2VuZFB0fWAsXG4gICAgICAgIHN0cm9rZVdpZHRoOiB3aWR0aCxcbiAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihib3JkZXJDb2xvcnMsIHBvcyksXG4gICAgICAgIHN0cm9rZURhc2hhcnJheTogZ2V0RGFzaEFycmF5KGJvcmRlclBhdHRlcm5zLCBwb3MpLFxuICAgICAgICBzdHJva2VMaW5lY2FwOiBnZXRCb3JkZXJTaGFwZShib3JkZXJTaGFwZXMsIGJvcmRlclBhdHRlcm5zLCBwb3MpLFxuICAgIH0pO1xufTtcbmNvbnN0IGdldFB0ID0gKHgsIHkpID0+IGAke3h9LCR7eX1gO1xuZXhwb3J0IGNvbnN0IFBhdGhPbkFyZWEgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGJvcmRlcldpZHRocywgYm9yZGVyQ29sb3JzLCBib3JkZXJQYXR0ZXJucywgYm9yZGVyU2hhcGVzLCBjbGFzc05hbWUsIHJ4ID0gMCwgcnkgPSAwLCB9ID0gcHJvcHM7XG4gICAgY29uc3QgUGF0aFByb3BzID0ge1xuICAgICAgICBib3JkZXJDb2xvcnMsXG4gICAgICAgIGJvcmRlclBhdHRlcm5zLFxuICAgICAgICBib3JkZXJTaGFwZXMsXG4gICAgfTtcbiAgICBjb25zdCBjb3JuZXJFeGlzdCA9IHJ4ICYmIHJ5O1xuICAgIGNvbnN0IGxlZnRUb3AgPSBnZXRQdCgwLCAwKTtcbiAgICBjb25zdCBsZWZ0Qm90dG9tID0gZ2V0UHQoMCwgaGVpZ2h0IC0gMCk7XG4gICAgY29uc3QgcmlnaHRUb3AgPSBnZXRQdCh3aWR0aCAtIDAsIDApO1xuICAgIGNvbnN0IHJpZ2h0Qm90dG9tID0gZ2V0UHQod2lkdGggLSAwLCBoZWlnaHQgLSAwKTtcbiAgICBpZiAoY29ybmVyRXhpc3QpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSAoYm9yZGVyV2lkdGhzICYmIEFycmF5LmlzQXJyYXkoYm9yZGVyV2lkdGhzKSA/IGJvcmRlcldpZHRoc1swXSA6IGJvcmRlcldpZHRocykgPz8gMDtcbiAgICAgICAgaWYgKCF3aWR0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBsZWZ0TGluZVRvcCA9IGdldFB0KDAsIHJ5KTtcbiAgICAgICAgY29uc3QgbGVmdExpbmVCb3R0b20gPSBnZXRQdCgwLCBoZWlnaHQgLSByeSk7XG4gICAgICAgIGNvbnN0IHRvcExpbmVMZWZ0ID0gZ2V0UHQocngsIDApO1xuICAgICAgICBjb25zdCB0b3BMaW5lUmlnaHQgPSBnZXRQdCh3aWR0aCAtIHJ4LCAwKTtcbiAgICAgICAgY29uc3QgcmlnaHRMaW5lVG9wID0gZ2V0UHQod2lkdGgsIHJ5KTtcbiAgICAgICAgY29uc3QgcmlnaHRMaW5lQm90dG9tID0gZ2V0UHQod2lkdGgsIGhlaWdodCAtIHJ5KTtcbiAgICAgICAgY29uc3QgYm90dG9tTGluZUxlZnQgPSBnZXRQdChyeCwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgYm90dG9tTGluZVJpZ2h0ID0gZ2V0UHQod2lkdGggLSByeCwgaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQoJ2cnLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSA/IGBwYXRocy1vbi1hcmVhICR7Y2xhc3NOYW1lfWAgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sIGVsZW1lbnQoJ3BhdGgnLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSA/IGAke2NsYXNzTmFtZX0tY29ybmVyLXBhdGhgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZDogYE0ke2xlZnRMaW5lVG9wfSBRJHtsZWZ0VG9wfSwke3RvcExpbmVMZWZ0fSBMJHt0b3BMaW5lUmlnaHR9IFEke3JpZ2h0VG9wfSwke3JpZ2h0TGluZVRvcH0gTCR7cmlnaHRMaW5lQm90dG9tfSBRJHtyaWdodEJvdHRvbX0sJHtib3R0b21MaW5lUmlnaHR9IEwke2JvdHRvbUxpbmVMZWZ0fSBRJHtsZWZ0Qm90dG9tfSwke2xlZnRMaW5lQm90dG9tfSBMJHtsZWZ0TGluZVRvcH1gLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgc3Ryb2tlOiBnZXRTdHJva2VDb2xvcihib3JkZXJDb2xvcnMpLFxuICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBnZXREYXNoQXJyYXkoYm9yZGVyUGF0dGVybnMpLFxuICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogZ2V0Qm9yZGVyU2hhcGUoYm9yZGVyU2hhcGVzLCBib3JkZXJQYXR0ZXJucyksXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGxlZnRXaWQgPSBnZXRXaWQoYm9yZGVyV2lkdGhzLCAnbGVmdCcpO1xuICAgICAgICBjb25zdCByaWdodFdpZCA9IGdldFdpZChib3JkZXJXaWR0aHMsICdyaWdodCcpO1xuICAgICAgICBjb25zdCB0b3BXaWQgPSBnZXRXaWQoYm9yZGVyV2lkdGhzLCAndG9wJyk7XG4gICAgICAgIGNvbnN0IGJvdHRvbVdpZCA9IGdldFdpZChib3JkZXJXaWR0aHMsICdib3R0b20nKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQoJ2cnLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSA/IGBwYXRocy1vbi1hcmVhICR7Y2xhc3NOYW1lfWAgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sICEhbGVmdFdpZCAmJlxuICAgICAgICAgICAgUGF0aCh7XG4gICAgICAgICAgICAgICAgc3RhcnRQdDogbGVmdFRvcCxcbiAgICAgICAgICAgICAgICBlbmRQdDogbGVmdEJvdHRvbSxcbiAgICAgICAgICAgICAgICB3aWR0aDogbGVmdFdpZCxcbiAgICAgICAgICAgICAgICAuLi5QYXRoUHJvcHMsXG4gICAgICAgICAgICAgICAgcG9zOiAnbGVmdCcsXG4gICAgICAgICAgICB9KSwgISFyaWdodFdpZCAmJlxuICAgICAgICAgICAgUGF0aCh7XG4gICAgICAgICAgICAgICAgc3RhcnRQdDogcmlnaHRUb3AsXG4gICAgICAgICAgICAgICAgZW5kUHQ6IHJpZ2h0Qm90dG9tLFxuICAgICAgICAgICAgICAgIHdpZHRoOiByaWdodFdpZCxcbiAgICAgICAgICAgICAgICAuLi5QYXRoUHJvcHMsXG4gICAgICAgICAgICAgICAgcG9zOiAncmlnaHQnLFxuICAgICAgICAgICAgfSksICEhdG9wV2lkICYmXG4gICAgICAgICAgICBQYXRoKHtcbiAgICAgICAgICAgICAgICBzdGFydFB0OiBsZWZ0VG9wLFxuICAgICAgICAgICAgICAgIGVuZFB0OiByaWdodFRvcCxcbiAgICAgICAgICAgICAgICB3aWR0aDogdG9wV2lkLFxuICAgICAgICAgICAgICAgIC4uLlBhdGhQcm9wcyxcbiAgICAgICAgICAgICAgICBwb3M6ICd0b3AnLFxuICAgICAgICAgICAgfSksICEhYm90dG9tV2lkICYmXG4gICAgICAgICAgICBQYXRoKHtcbiAgICAgICAgICAgICAgICBzdGFydFB0OiBsZWZ0Qm90dG9tLFxuICAgICAgICAgICAgICAgIGVuZFB0OiByaWdodEJvdHRvbSxcbiAgICAgICAgICAgICAgICB3aWR0aDogYm90dG9tV2lkLFxuICAgICAgICAgICAgICAgIC4uLlBhdGhQcm9wcyxcbiAgICAgICAgICAgICAgICBwb3M6ICdib3R0b20nLFxuICAgICAgICAgICAgfSkpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXRoT25BcmVhLmpzLm1hcCIsImltcG9ydCB7IGdldFJlY3RTdHlsZSwgZ2V0V2lkVmlzaWJsZSwgaXNCb3JkZXJSZWN0IH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBQYXRoT25BcmVhIH0gZnJvbSAnLi9QYXRoT25BcmVhJztcbmltcG9ydCB7IGVsZW1lbnQgfSBmcm9tICcuL2VsZW1lbnQnO1xuY29uc3QgRmlsbGVkQXJlYSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgYmdDb2xvciwgd2lkdGgsIGhlaWdodCwgYm9yZGVyV2lkdGhzLCBib3JkZXJDb2xvcnMsIGJvcmRlclBhdHRlcm5zLCBib3JkZXJTaGFwZXMsIGNsYXNzTmFtZSwgcngsIHJ5IH0gPSBwcm9wcztcbiAgICBjb25zdCBpc0JnQ29sb3JWaXNpYmxlID0gYmdDb2xvciAmJiBiZ0NvbG9yICE9PSAndHJhbnNwYXJlbnQnO1xuICAgIGNvbnN0IGlzQm9yZGVyT25SZWN0ID0gaXNCZ0NvbG9yVmlzaWJsZSAmJiBpc0JvcmRlclJlY3QocHJvcHMpO1xuICAgIGNvbnN0IHJlY3RTdHlsZVByb3BzID0gaXNCb3JkZXJPblJlY3QgPyBnZXRSZWN0U3R5bGUocHJvcHMpIDogeyBmaWxsOiBiZ0NvbG9yIH07XG4gICAgY29uc3QgaXNGaWxsZWRBcmVhVmlzaWJsZSA9IGlzQmdDb2xvclZpc2libGUgfHwgZ2V0V2lkVmlzaWJsZShib3JkZXJXaWR0aHMpO1xuICAgIHJldHVybiBpc0ZpbGxlZEFyZWFWaXNpYmxlXG4gICAgICAgID8gZWxlbWVudCgnZycsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYGZpbGxlZC1hcmVhICR7Y2xhc3NOYW1lID8/ICcnfWAgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sIGlzQmdDb2xvclZpc2libGUgJiZcbiAgICAgICAgICAgIGVsZW1lbnQoJ3JlY3QnLCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgIC4uLnJlY3RTdHlsZVByb3BzLFxuICAgICAgICAgICAgfSksICFpc0JvcmRlck9uUmVjdCAmJlxuICAgICAgICAgICAgUGF0aE9uQXJlYSh7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgPyAncGF0aHMtb24tYXJlYS1mb3ItZmlsbGVkLWFyZWEnIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICBib3JkZXJXaWR0aHM6IGJvcmRlcldpZHRocyxcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcnM6IGJvcmRlckNvbG9ycyxcbiAgICAgICAgICAgICAgICBib3JkZXJQYXR0ZXJuczogYm9yZGVyUGF0dGVybnMsXG4gICAgICAgICAgICAgICAgYm9yZGVyU2hhcGVzOiBib3JkZXJTaGFwZXMsXG4gICAgICAgICAgICAgICAgcngsXG4gICAgICAgICAgICAgICAgcnksXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG59O1xuZXhwb3J0IGRlZmF1bHQgRmlsbGVkQXJlYTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbGxlZEFyZWEuanMubWFwIiwiaW1wb3J0IHsgZ2V0RHVwbGljYXRlZFByb3BzLCBzaW1wbGVWYWx1ZSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgZWxlbWVudCB9IGZyb20gJy4vZWxlbWVudCc7XG5leHBvcnQgY29uc3QgQ2VudGVyZWRDZWxsQ29udGVudCA9ICh7IGNlbGxPcHQsIHN0eWxlVG9Vc2UsIGNoaWxkcmVuLCB9KSA9PiB7XG4gICAgbGV0IHsgd2lkdGgsIGhlaWdodCwgY2xhc3NOYW1lIH0gPSBjZWxsT3B0O1xuICAgIGxldCB7IHJvdGF0ZUNlbnRlclByb3BzLCBjeCA9IDAsIGN5ID0gMCB9ID0gc3R5bGVUb1VzZTtcbiAgICBjb25zdCBwcm9wc1RvUGFzc0Zvckdyb3VwID0gKHN0YXJ0WCwgc3RhcnRZKSA9PiAoe1xuICAgICAgICB4OiBzaW1wbGVWYWx1ZShzdGFydFgpLFxuICAgICAgICB5OiBzaW1wbGVWYWx1ZShzdGFydFkpLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgIH0pO1xuICAgIGNvbnN0IHJvdGF0aW9uR3JvdXBQcm9wcyA9IHtcbiAgICAgICAgLi4uKHR5cGVvZiByb3RhdGVDZW50ZXJQcm9wcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyByb3RhdGVDZW50ZXJQcm9wcyhwcm9wc1RvUGFzc0Zvckdyb3VwKHdpZHRoIC8gMiArIGN4LCBoZWlnaHQgLyAyICsgY3kpKVxuICAgICAgICAgICAgOiByb3RhdGVDZW50ZXJQcm9wcyksXG4gICAgfTtcbiAgICBnZXREdXBsaWNhdGVkUHJvcHMocm90YXRpb25Hcm91cFByb3BzKTtcbiAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCAxKTtcbiAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIDEpO1xuICAgIHJldHVybiBlbGVtZW50KCdzdmcnLCB7XG4gICAgICAgIHZpZXdCb3g6IGAkey13aWR0aCAvIDJ9ICR7LWhlaWdodCAvIDJ9ICR7d2lkdGh9ICR7aGVpZ2h0fWAsXG4gICAgICAgIHN0eWxlOiB7IG92ZXJmbG93OiAndmlzaWJsZScgfSxcbiAgICB9LCBlbGVtZW50KCdnJywge1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSA/IGAke2NsYXNzTmFtZX0tY29udGVudGAgOiB1bmRlZmluZWQsXG4gICAgfSwgZWxlbWVudCgnZycsIHJvdGF0aW9uR3JvdXBQcm9wcywgY2hpbGRyZW4pKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2VudGVyZWRDZWxsQ29udGVudC5qcy5tYXAiLCJpbXBvcnQgeyBnZXREdXBsaWNhdGVkUHJvcHMsIGdldFdpZCwgc2ltcGxlVmFsdWUgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBGaWxsZWRBcmVhIGZyb20gJy4vRmlsbGVkQXJlYSc7XG5pbXBvcnQgeyBDZW50ZXJlZENlbGxDb250ZW50IH0gZnJvbSAnLi9DZW50ZXJlZENlbGxDb250ZW50JztcbmltcG9ydCB7IGVsZW1lbnQgfSBmcm9tICcuL2VsZW1lbnQnO1xuaW1wb3J0IHsgU1ZHVGFibGVCYXNlIH0gZnJvbSAnLi9TVkdUYWJsZUJhc2UnO1xuY29uc3QgbW92ZVRvTGVmdFRvcCA9ICh3aWR0aCwgaGVpZ2h0LCBjb250ZW50KSA9PiB7XG4gICAgcmV0dXJuIGVsZW1lbnQoJ2cnLCB7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgkey13aWR0aCAvIDJ9LCAkey1oZWlnaHQgLyAyfSlgLFxuICAgIH0sIGNvbnRlbnQpO1xufTtcbmNvbnN0IGNvbnZlcnRUb1RhYmxlSWZOZWVkZWQgPSAoY29udGVudFRvdXNlLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5ncywgY2VsbE9wdCkgPT4ge1xuICAgIGlmIChjb250ZW50VG91c2UudGFibGUpIHtcbiAgICAgICAgY29uc3QgcGFkTGVmdCA9IGdldFdpZChwYWRkaW5ncywgJ2xlZnQnKTtcbiAgICAgICAgY29uc3QgcGFkVG9wID0gZ2V0V2lkKHBhZGRpbmdzLCAndG9wJyk7XG4gICAgICAgIGNvbnN0IHBhZFJpZ2h0ID0gZ2V0V2lkKHBhZGRpbmdzLCAncmlnaHQnKTtcbiAgICAgICAgY29uc3QgcGFkQm90dG9tID0gZ2V0V2lkKHBhZGRpbmdzLCAnYm90dG9tJyk7XG4gICAgICAgIGNvbnN0IHRhYmxlV2lkID0gc2ltcGxlVmFsdWUod2lkdGggLSBwYWRSaWdodCAtIHBhZExlZnQpO1xuICAgICAgICBjb25zdCBhZGp1c3RQcm9wcyA9IGNlbGxPcHQuX2hlaWdodEFkanVzdFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzaW1wbGVWYWx1ZShNYXRoLm1heChoZWlnaHQgLSBwYWRUb3AgLSBwYWRCb3R0b20sIDEpKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge307XG4gICAgICAgIGlmIChjZWxsT3B0Ll9zdGFuZGFsb25lKVxuICAgICAgICAgICAgYWRqdXN0UHJvcHMuc3RhbmRhbG9uZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBTVkdUYWJsZUJhc2Uoe1xuICAgICAgICAgICAgd2lkdGg6IHNpbXBsZVZhbHVlKHRhYmxlV2lkKSxcbiAgICAgICAgICAgIC4uLmFkanVzdFByb3BzLFxuICAgICAgICAgICAgLi4uY29udGVudFRvdXNlLnRhYmxlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRlbnRUb3VzZTtcbn07XG5jb25zdCByZW5kZXJUZXh0T25seSA9IChjb250ZW50VG9SZW5kZXIsIHN0YXJ0WCwgc3RhcnRZLCB0ZXh0QW5jaG9yLCBzdHlsZVRvQXBwbHkgPSB7fSkgPT4ge1xuICAgIGNvbnN0IGxpbmVzID0gY29udGVudFRvUmVuZGVyLnNwbGl0KCdcXG4nKTtcbiAgICBsZXQgdGV4dFRvUmVuZGVyID0gW2NvbnRlbnRUb1JlbmRlcl07XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSBzdHlsZVRvQXBwbHkuZm9udFNpemUgfHwgMTY7XG4gICAgICAgIHRleHRUb1JlbmRlciA9IGxpbmVzXG4gICAgICAgICAgICAuZmlsdGVyKHYgPT4gdilcbiAgICAgICAgICAgIC5tYXAoKGxpbmUsIGluZGV4KSA9PiBlbGVtZW50KCd0c3BhbicsIHtcbiAgICAgICAgICAgIGZvbnRTaXplLFxuICAgICAgICAgICAgeDogc3RhcnRYLFxuICAgICAgICAgICAgZHk6IGluZGV4ID09PSAwID8gMCA6IGZvbnRTaXplLFxuICAgICAgICB9LCBsaW5lKSk7XG4gICAgICAgIHN0YXJ0WSA9IHN0YXJ0WSAtICgobGluZXMubGVuZ3RoIC0gMSkgKiBzaW1wbGVWYWx1ZShmb250U2l6ZSkpIC8gMjtcbiAgICB9XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgIHg6IHNpbXBsZVZhbHVlKHN0YXJ0WCksXG4gICAgICAgIHk6IHNpbXBsZVZhbHVlKHN0YXJ0WSksXG4gICAgICAgIHRleHRBbmNob3I6IHRleHRBbmNob3IsXG4gICAgICAgIGRvbWluYW50QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgICAuLi5zdHlsZVRvQXBwbHksXG4gICAgfTtcbiAgICBnZXREdXBsaWNhdGVkUHJvcHMocHJvcHMpO1xuICAgIHJldHVybiBlbGVtZW50KCd0ZXh0JywgcHJvcHMsIC4uLnRleHRUb1JlbmRlcik7XG59O1xuY29uc3Qgc3R5bGVXaXRoRmlsbCA9IChzdHlsZSwgY29sb3IpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgLi4uc3R5bGUsXG4gICAgfTtcbn07XG5jb25zdCBnZXRBcmlhUHJvcHMgPSAoY2VsbE9wdCkgPT4ge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgJ2FyaWEtY29sc3Bhbic6IGNlbGxPcHQuY29sU3BhbiAmJiBjZWxsT3B0LmNvbFNwYW4gPiAxID8gY2VsbE9wdC5jb2xTcGFuIDogdW5kZWZpbmVkLFxuICAgICAgICAnYXJpYS1yb3dzcGFuJzogY2VsbE9wdC5yb3dTcGFuICYmIGNlbGxPcHQucm93U3BhbiA+IDEgPyBjZWxsT3B0LnJvd1NwYW4gOiB1bmRlZmluZWQsXG4gICAgfSkpO1xufTtcbmNvbnN0IGdldENvbnRlbnRzID0gKGNlbGxPcHQsIHN0eWxlVG9Vc2UpID0+IHtcbiAgICBjb25zdCB7IGNvbnRlbnQsIHdpZHRoLCBoZWlnaHQsIGJlZm9yZSwgYWZ0ZXIgfSA9IGNlbGxPcHQ7XG4gICAgbGV0IHsgcGFkZGluZ3MsIHRleHRDb2xvciwgdGV4dFN0eWxlLCBjeCA9IDAsIGN5ID0gMCB9ID0gc3R5bGVUb1VzZTtcbiAgICB0ZXh0U3R5bGUgPSBzdHlsZVdpdGhGaWxsKHRleHRTdHlsZSwgdGV4dENvbG9yKTtcbiAgICBjb25zdCB7IGNvbnRlbnQ6IGJlZm9yZTIsIC4uLmJlZm9yZU9wdHMgfSA9IHR5cGVvZiBiZWZvcmUgPT09ICdvYmplY3QnICYmIGJlZm9yZS5jb250ZW50XG4gICAgICAgID8gYmVmb3JlXG4gICAgICAgIDogeyBjb250ZW50OiBiZWZvcmUgfTtcbiAgICBjb25zdCB7IGNvbnRlbnQ6IGFmdGVyMiwgLi4uYWZ0ZXJPcHRzIH0gPSB0eXBlb2YgYWZ0ZXIgPT09ICdvYmplY3QnICYmIGFmdGVyLmNvbnRlbnRcbiAgICAgICAgPyBhZnRlclxuICAgICAgICA6IHsgY29udGVudDogYWZ0ZXIgfTtcbiAgICBjb25zdCBiZWZvcmVUZXh0U3R5bGUgPSBzdHlsZVdpdGhGaWxsKGJlZm9yZU9wdHMudGV4dFN0eWxlLCB0ZXh0Q29sb3IpO1xuICAgIGNvbnN0IGFmdGVyVGV4dFN0eWxlID0gc3R5bGVXaXRoRmlsbChhZnRlck9wdHMudGV4dFN0eWxlLCB0ZXh0Q29sb3IpO1xuICAgIGNvbnN0IHByb3BzVG9QYXNzID0gKHRleHRTdHlsZVRvVXNlLCBhbmNob3JCYXNlLCBzdGFydFgsIHN0YXJ0WSkgPT4gKHtcbiAgICAgICAgeDogc2ltcGxlVmFsdWUoc3RhcnRYKSxcbiAgICAgICAgeTogc2ltcGxlVmFsdWUoc3RhcnRZKSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdGV4dENvbG9yLFxuICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICAgIHRleHRBbmNob3I6IGFuY2hvckJhc2UsXG4gICAgICAgICAgICBkb21pbmFudEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIC4uLnRleHRTdHlsZVRvVXNlLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGdldENvbnRlbnQgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBjb250ZW50KHByb3BzVG9QYXNzKHRleHRTdHlsZSwgJ21pZGRsZScsIHdpZHRoIC8gMiArIGN4LCBoZWlnaHQgLyAyICsgY3kpKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNvbnZlcnRUb1RhYmxlSWZOZWVkZWQoY29udGVudCwgd2lkdGgsIGhlaWdodCwgcGFkZGluZ3MsIGNlbGxPcHQpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY29udGVudFRvVXNlID0gZ2V0Q29udGVudCgpO1xuICAgIGxldCBiZWZvcmVUb1VzZSA9IHR5cGVvZiBiZWZvcmUyID09PSAnZnVuY3Rpb24nID8gYmVmb3JlMihwcm9wc1RvUGFzcyhiZWZvcmVUZXh0U3R5bGUsICdzdGFydCcsIDAsIGhlaWdodCAvIDIpKSA6IGJlZm9yZTI7XG4gICAgbGV0IGFmdGVyVG9Vc2UgPSB0eXBlb2YgYWZ0ZXIyID09PSAnZnVuY3Rpb24nID8gYWZ0ZXIyKHByb3BzVG9QYXNzKGFmdGVyVGV4dFN0eWxlLCAnZW5kJywgd2lkdGgsIGhlaWdodCAvIDIpKSA6IGFmdGVyMjtcbiAgICBjb25zdCBiZWZvcmVDb250ZW50ID0gYmVmb3JlVG9Vc2UgJiYgdHlwZW9mIGJlZm9yZVRvVXNlID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHJlbmRlclRleHRPbmx5KGJlZm9yZVRvVXNlLCAwLCBoZWlnaHQgLyAyLCAnc3RhcnQnLCBiZWZvcmVUZXh0U3R5bGUpXG4gICAgICAgIDogYmVmb3JlVG9Vc2U7XG4gICAgY29uc3QgYWZ0ZXJDb250ZW50ID0gYWZ0ZXJUb1VzZSAmJiB0eXBlb2YgYWZ0ZXJUb1VzZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyByZW5kZXJUZXh0T25seShhZnRlclRvVXNlLCB3aWR0aCwgaGVpZ2h0IC8gMiwgJ2VuZCcsIGFmdGVyVGV4dFN0eWxlKVxuICAgICAgICA6IGFmdGVyVG9Vc2U7XG4gICAgY29uc3QgbWFpbkNvbnRlbnQgPSB0eXBlb2YgY29udGVudFRvVXNlID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHJlbmRlclRleHRPbmx5KGNvbnRlbnRUb1VzZSwgY3gsIGN5LCAnbWlkZGxlJywgdGV4dFN0eWxlKVxuICAgICAgICA6IG1vdmVUb0xlZnRUb3Aod2lkdGgsIGhlaWdodCwgY29udGVudFRvVXNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBiZWZvcmVDb250ZW50LFxuICAgICAgICBhZnRlckNvbnRlbnQsXG4gICAgICAgIG1haW5Db250ZW50LFxuICAgIH07XG59O1xuY29uc3QgRmlsbGVkQXJlYUluQ2VsbCA9ICh7IGNlbGxPcHQsIHN0eWxlVG9Vc2UsIH0pID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGNsYXNzTmFtZSB9ID0gY2VsbE9wdDtcbiAgICBsZXQgeyBiZ0NvbG9yLCBib3JkZXJXaWR0aHMsIGJvcmRlckNvbG9ycywgYm9yZGVyUGF0dGVybnMsIGJvcmRlclNoYXBlcywgcngsIHJ5IH0gPSBzdHlsZVRvVXNlO1xuICAgIHJldHVybiBGaWxsZWRBcmVhKHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgPyBgJHtjbGFzc05hbWV9LWZpbGxlZC1iYWNrYCA6IHVuZGVmaW5lZCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgYm9yZGVyV2lkdGhzOiBib3JkZXJXaWR0aHMsXG4gICAgICAgIGJvcmRlckNvbG9yczogYm9yZGVyQ29sb3JzLFxuICAgICAgICBib3JkZXJQYXR0ZXJuczogYm9yZGVyUGF0dGVybnMsXG4gICAgICAgIGJvcmRlclNoYXBlczogYm9yZGVyU2hhcGVzLFxuICAgICAgICByeCxcbiAgICAgICAgcnksXG4gICAgICAgIC4uLihiZ0NvbG9yID8geyBiZ0NvbG9yIH0gOiB7fSksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNvbnN0IEFDZWxsID0gKHsgY2VsbE9wdCwgZGVmYXVsdFN0eWxlLCB9KSA9PiB7XG4gICAgaWYgKGNlbGxPcHQuX2lnbm9yZWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB7IHgsIHksIHdpZHRoLCBoZWlnaHQsIHN0eWxlLCBjbGFzc05hbWUgfSA9IGNlbGxPcHQ7XG4gICAgY29uc3Qgc3R5bGVUb1VzZSA9IHtcbiAgICAgICAgLi4uZGVmYXVsdFN0eWxlLFxuICAgICAgICAuLi5zdHlsZSxcbiAgICB9O1xuICAgIGxldCB7IHBhZGRpbmdzLCBzdmdTdHlsZSwgYWxsb3dPdmVyZmxvdyB9ID0gc3R5bGVUb1VzZTtcbiAgICBjb25zdCBwYWRMZWZ0ID0gZ2V0V2lkKHBhZGRpbmdzLCAnbGVmdCcpO1xuICAgIGNvbnN0IHBhZFRvcCA9IGdldFdpZChwYWRkaW5ncywgJ3RvcCcpO1xuICAgIGNvbnN0IHN2Z1N0eWxlVG9Vc2UgPSB7XG4gICAgICAgIC4uLnN2Z1N0eWxlLFxuICAgICAgICAuLi4oYWxsb3dPdmVyZmxvdyA/IHsgb3ZlcmZsb3c6ICd2aXNpYmxlJyB9IDoge30pLFxuICAgIH07XG4gICAgY29uc3QgYXJpYVByb3BzID0gZ2V0QXJpYVByb3BzKGNlbGxPcHQpO1xuICAgIGNvbnN0IHsgYmVmb3JlQ29udGVudCwgYWZ0ZXJDb250ZW50LCBtYWluQ29udGVudCB9ID0gZ2V0Q29udGVudHMoY2VsbE9wdCwgc3R5bGVUb1VzZSk7XG4gICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgMSk7XG4gICAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCAxKTtcbiAgICByZXR1cm4gZWxlbWVudCgnZycsIHtcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7eH0sICR7eX0pYCxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgPyBgJHtjbGFzc05hbWV9LXdyYXBwZXJgIDogdW5kZWZpbmVkLFxuICAgIH0sIEZpbGxlZEFyZWFJbkNlbGwoeyBjZWxsT3B0OiBjZWxsT3B0LCBzdHlsZVRvVXNlOiBzdHlsZVRvVXNlIH0pLCBlbGVtZW50KCdzdmcnLCB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHN0eWxlOiBzdmdTdHlsZVRvVXNlLFxuICAgICAgICB2aWV3Qm94OiBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWAsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lID8gY2xhc3NOYW1lIDogdW5kZWZpbmVkLFxuICAgIH0sIGVsZW1lbnQoJ2cnLCB7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke3BhZExlZnR9LCAke3BhZFRvcH0pYCxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgPyBgJHtjbGFzc05hbWV9LXBhZGRpbmdgIDogdW5kZWZpbmVkLFxuICAgICAgICByb2xlOiAnY2VsbCcsXG4gICAgICAgIC4uLmFyaWFQcm9wcyxcbiAgICB9LCBiZWZvcmVDb250ZW50LCBDZW50ZXJlZENlbGxDb250ZW50KHtcbiAgICAgICAgY2VsbE9wdDogY2VsbE9wdCxcbiAgICAgICAgc3R5bGVUb1VzZTogc3R5bGVUb1VzZSxcbiAgICAgICAgY2hpbGRyZW46IG1haW5Db250ZW50LFxuICAgIH0pLCBhZnRlckNvbnRlbnQpKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QUNlbGwuanMubWFwIiwiaW1wb3J0IHsgc2ltcGxlVmFsdWUgfSBmcm9tICcuL3V0aWxzJztcbmxldCBkZWJ1Z09iaiA9IHt9O1xuY29uc3QgZ2V0Q2VsbFdpZHRoID0gKGNlbGxXaWR0aHMsIHN0YXJ0Q29sLCBjb2xTcGFuLCBjb2xHYXApID0+IHtcbiAgICBpZiAoY2VsbFdpZHRocy5sZW5ndGggPCBzdGFydENvbCArIGNvbFNwYW4gLSAxKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vdCBlbm91Z2ggY29sdW1uIHdpZHRocyBwcm92aWRlZC4gY2hlY2sgY29sU3BhbiBvZiB0aGUgY2VsbCBkYXRhLiBzdGFydENvbDogJyArIHN0YXJ0Q29sLCAnZGF0YSBpczonLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRlYnVnT2JqKSkpO1xuICAgIH1cbiAgICByZXR1cm4gc2ltcGxlVmFsdWUoY2VsbFdpZHRocy5zbGljZShzdGFydENvbCwgc3RhcnRDb2wgKyBjb2xTcGFuKS5yZWR1Y2UoKHRvdGFsLCB3aWR0aCkgPT4gdG90YWwgKyB3aWR0aCwgMCkgK1xuICAgICAgICBjb2xHYXAgKiAoY29sU3BhbiAtIDEpKTtcbn07XG5jb25zdCBnZXRDZWxsSGVpZ2h0ID0gKHJvd0hlaWdodHMsIHN0YXJ0Um93LCByb3dTcGFuLCByb3dHYXApID0+IHtcbiAgICBpZiAocm93SGVpZ2h0cy5sZW5ndGggPCBzdGFydFJvdyArIHJvd1NwYW4gLSAxKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vdCBlbm91Z2ggcm93IGhlaWdodHMgcHJvdmlkZWQuIGNoZWNrIHJvd1NwYW4gb2YgdGhlIGNlbGwgZGF0YS4gc3RhcnRSb3c6ICcgKyBzdGFydFJvdywgJ2RhdGEgaXM6JywgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkZWJ1Z09iaikpKTtcbiAgICB9XG4gICAgcmV0dXJuIChyb3dIZWlnaHRzLnNsaWNlKHN0YXJ0Um93LCBzdGFydFJvdyArIHJvd1NwYW4pLnJlZHVjZSgodG90YWwsIGhlaWdodCkgPT4gdG90YWwgKyBoZWlnaHQsIDApICtcbiAgICAgICAgcm93R2FwICogKHJvd1NwYW4gLSAxKSk7XG59O1xuY29uc3QgaW5zZXJ0SWdub3JlZENlbGwgPSAocm93LCBjb2xJbmRleCwgY2VsbCkgPT4ge1xuICAgIHJvdy5jZWxscyA9IFtcbiAgICAgICAgLi4uKHJvdy5jZWxscy5zbGljZSgwLCBjb2xJbmRleCkgPz8gW10pLFxuICAgICAgICAuLi5BcnJheShjZWxsLmNvbFNwYW4gPz8gMSlcbiAgICAgICAgICAgIC5maWxsKG51bGwpXG4gICAgICAgICAgICAubWFwKCgpID0+ICh7XG4gICAgICAgICAgICBfaWdub3JlZDogdHJ1ZSxcbiAgICAgICAgICAgIGNvbFNwYW46IDEsXG4gICAgICAgIH0pKSxcbiAgICAgICAgLi4uKHJvdy5jZWxscy5zbGljZShjb2xJbmRleCkgPz8gW10pLFxuICAgIF07XG59O1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZVJvd3MgPSAoY2VsbFdpZHRocywgcm93SGVpZ2h0cywgcm93cywgc3R5bGUsIHRhYmxlUHJvcHMpID0+IHtcbiAgICBsZXQgY3VycmVudFkgPSAwO1xuICAgIGNvbnN0IGVtYmVkZWRUYWJsZUhlaWdodEFkanVzdCA9ICEhdGFibGVQcm9wcy5oZWlnaHQ7XG4gICAgY29uc3Qgc3RhbmRhbG9uZVRhYmxlID0gISF0YWJsZVByb3BzLnN0YW5kYWxvbmU7XG4gICAgY29uc3QgY2FsY1Jvd3MgPSByb3dzLm1hcChhUm93ID0+IHtcbiAgICAgICAgY29uc3Qgcm93ID0gQXJyYXkuaXNBcnJheShhUm93KSA/IHsgY2VsbHM6IGFSb3cgfSA6IGFSb3c7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yb3csXG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogY3VycmVudFksXG4gICAgICAgICAgICBoZWlnaHQ6IC0xLFxuICAgICAgICAgICAgd2lkdGg6IC0xLFxuICAgICAgICAgICAgY2VsbHM6IFtcbiAgICAgICAgICAgICAgICAuLi5yb3cuY2VsbHMubWFwKGFDZWxsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IHR5cGVvZiBhQ2VsbCA9PT0gJ3N0cmluZycgPyB7IGNvbnRlbnQ6IGFDZWxsIH0gOiBhQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNlbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pZ25vcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oZWlnaHRBZGp1c3Q6IGVtYmVkZWRUYWJsZUhlaWdodEFkanVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGFuZGFsb25lOiBzdGFuZGFsb25lVGFibGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGZvciAobGV0IHJpID0gMDsgcmkgPCBjYWxjUm93cy5sZW5ndGg7IHJpKyspIHtcbiAgICAgICAgY29uc3Qgcm93ID0gY2FsY1Jvd3NbcmldO1xuICAgICAgICBpZiAoIXJvdylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgY3VycmVudFggPSAwO1xuICAgICAgICBsZXQgaWR4ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHJvdy5jZWxscykge1xuICAgICAgICAgICAgZGVidWdPYmogPSB7XG4gICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgY2VsbDogY2VsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY2VsbC5faWdub3JlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpZFRvU2tpcCA9IGdldENlbGxXaWR0aChjZWxsV2lkdGhzLCBpZHgsIDEsIHN0eWxlPy5jb2xHYXBzID8/IDApO1xuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRYICs9IHdpZFRvU2tpcCArIChzdHlsZT8uY29sR2FwcyA/PyAwKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzTGFzdENlbGxCdXROb3RMYXN0Q29sdW1uID0gcm93LmNlbGxzW3Jvdy5jZWxscy5sZW5ndGggLSAxXSA9PT0gY2VsbCAmJiBpZHggIT09IGNlbGxXaWR0aHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGNvbFNwYW4gPSBpc0xhc3RDZWxsQnV0Tm90TGFzdENvbHVtbiA/IGNlbGxXaWR0aHMubGVuZ3RoIC0gaWR4IDogMTtcbiAgICAgICAgICAgIGNlbGwuY29sU3BhbiA9IGNvbFNwYW47XG4gICAgICAgICAgICBjb25zdCBjZWxsV2lkdGggPSBnZXRDZWxsV2lkdGgoY2VsbFdpZHRocywgaWR4LCBjZWxsLmNvbFNwYW4sIHN0eWxlPy5jb2xHYXBzID8/IDApO1xuICAgICAgICAgICAgaWYgKGNlbGwucm93U3Bhbikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY2VsbC5yb3dTcGFuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGNSb3dzW3JpICsgaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydElnbm9yZWRDZWxsKGNhbGNSb3dzW3JpICsgaV0sIGlkeCwgY2VsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyb3cgaXMgbm90IGZvdW5kIGF0IGluZGV4OiAnICsgKGlkeCArIGkpLCAneW91ciBjZWxsIGlzOicsIGNlbGwsICd5b3VyIHJvd3MgYXJlJywgY2FsY1Jvd3MsICdpZHggaXMnLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VsbC53aWR0aCA9IGNlbGxXaWR0aDtcbiAgICAgICAgICAgIGNlbGwuaGVpZ2h0ID0gZ2V0Q2VsbEhlaWdodChyb3dIZWlnaHRzLCByaSwgY2VsbC5yb3dTcGFuID8/IDEsIHN0eWxlPy5yb3dHYXBzID8/IDApO1xuICAgICAgICAgICAgY2VsbC54ID0gc2ltcGxlVmFsdWUoY3VycmVudFgpO1xuICAgICAgICAgICAgY2VsbC55ID0gc2ltcGxlVmFsdWUoY3VycmVudFkpO1xuICAgICAgICAgICAgY3VycmVudFggKz0gY2VsbFdpZHRoICsgKHN0eWxlPy5jb2xHYXBzID8/IDApO1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFkgKz0gKHJvd0hlaWdodHNbcmldID8/IDApICsgKHN0eWxlPy5yb3dHYXBzID8/IDApO1xuICAgICAgICByb3cuaGVpZ2h0ID0gY3VycmVudFk7XG4gICAgICAgIHJvdy53aWR0aCA9IGN1cnJlbnRYO1xuICAgIH1cbiAgICByZXR1cm4gY2FsY1Jvd3M7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsY3VsYXRlUm93cy5qcy5tYXAiLCJpbXBvcnQgeyBBQ2VsbCB9IGZyb20gJy4vQUNlbGwnO1xuaW1wb3J0IHsgY2FsY3VsYXRlUm93cyB9IGZyb20gJy4vY2FsY3VsYXRlUm93cyc7XG5pbXBvcnQgeyBnZXRXaWQsIHNpbXBsZVZhbHVlIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgRmlsbGVkQXJlYSBmcm9tICcuL0ZpbGxlZEFyZWEnO1xuaW1wb3J0IHsgSU5URVJOQUxfQ1NTX1ZBUlMgfSBmcm9tICcuL2NvbnN0cyc7XG5pbXBvcnQgeyBlbGVtZW50IH0gZnJvbSAnLi9lbGVtZW50JztcbmNvbnN0IGdldFRvdGFsQ2VsbHMgPSAoY2VsbHMpID0+IHtcbiAgICByZXR1cm4gY2VsbHMucmVkdWNlKCh0b3RhbCwgY2VsbCkgPT4ge1xuICAgICAgICBjb25zdCBjZWxsQXNPYmogPSBjZWxsO1xuICAgICAgICBpZiAodHlwZW9mIGNlbGxBc09iaiA9PT0gJ29iamVjdCcgJiYgY2VsbEFzT2JqLmNvbFNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbCArIGNlbGxBc09iai5jb2xTcGFuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbCArIDE7XG4gICAgfSwgMCk7XG59O1xuY29uc3QgcGFyc2VkVGFibGVTdHlsZSA9IChzdHlsZSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvd0dhcHM6IDAsXG4gICAgICAgIGNvbEdhcHM6IDAsXG4gICAgICAgIGJvcmRlcldpZHRoczogdW5kZWZpbmVkLFxuICAgICAgICBib3JkZXJQYXR0ZXJuczogdW5kZWZpbmVkLFxuICAgICAgICBib3JkZXJTaGFwZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgYm9yZGVyQ29sb3JzOiBzdHlsZT8uYm9yZGVyV2lkdGhzID8gYHZhcigke0lOVEVSTkFMX0NTU19WQVJTLmJvcmRlckxpbmVDb2xvcn0sICMwMDApYCA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ZnU3R5bGU6IHsgb3ZlcmZsb3c6ICd2aXNpYmxlJyB9LFxuICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgbWFyZ2luczogc3R5bGU/Lm1hcmdpbnMgPz8gMCxcbiAgICB9O1xufTtcbmNvbnN0IHBhcnNlRGVmYXVsdENlbGxTdHlsZUJhc2UgPSAoZGVmYXVsdENlbGxTdHlsZUJhc2UpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxvd092ZXJmbG93OiBmYWxzZSxcbiAgICAgICAgYm9yZGVyV2lkdGhzOiAxLFxuICAgICAgICBiZ0NvbG9yOiB1bmRlZmluZWQsXG4gICAgICAgIHRleHRTdHlsZTogdW5kZWZpbmVkLFxuICAgICAgICBib3JkZXJDb2xvcnM6IGB2YXIoJHtJTlRFUk5BTF9DU1NfVkFSUy5ib3JkZXJMaW5lQ29sb3J9LCAjMDAwKWAsXG4gICAgICAgIGJvcmRlclBhdHRlcm5zOiB1bmRlZmluZWQsXG4gICAgICAgIGJvcmRlclNoYXBlczogdW5kZWZpbmVkLFxuICAgICAgICBwYWRkaW5nczogWzEsIDEsIDEsIDFdLFxuICAgICAgICB0ZXh0Q29sb3I6IGB2YXIoJHtJTlRFUk5BTF9DU1NfVkFSUy50ZXh0Q29sb3J9LCAjMDAwKWAsXG4gICAgICAgIC4uLmRlZmF1bHRDZWxsU3R5bGVCYXNlLFxuICAgICAgICBvbmx5SW5uZXJCb3JkZXJzOiBkZWZhdWx0Q2VsbFN0eWxlQmFzZT8ucnggJiYgZGVmYXVsdENlbGxTdHlsZUJhc2U/LnJ5XG4gICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgIDogKGRlZmF1bHRDZWxsU3R5bGVCYXNlPy5vbmx5SW5uZXJCb3JkZXJzID8/IGZhbHNlKSxcbiAgICB9O1xufTtcbmNvbnN0IGFkanVzdENvbHVtbldpZHRocyA9IChjb2x1bW5XaWR0aHMsIHRhYmxlV2lkdGhXaXRob3V0R2FwcykgPT4ge1xuICAgIGNvbnN0IHRvdGFsV2lkdGggPSBjb2x1bW5XaWR0aHMucmVkdWNlKCh0b3RhbCwgd2lkdGgpID0+IHRvdGFsICsgd2lkdGgsIDApO1xuICAgIGNvbnN0IHJhdGlvID0gdGFibGVXaWR0aFdpdGhvdXRHYXBzIC8gdG90YWxXaWR0aDtcbiAgICBpZiAocmF0aW8gPiAwLjk5ICYmIHJhdGlvIDw9IDEuMDEpXG4gICAgICAgIHJldHVybiBjb2x1bW5XaWR0aHM7XG4gICAgcmV0dXJuIGNvbHVtbldpZHRocy5tYXAod2lkdGggPT4gTWF0aC5tYXgoc2ltcGxlVmFsdWUod2lkdGggKiByYXRpbyksIDEpKTtcbn07XG5jb25zdCBhZGp1c3RSb3dIZWlnaHRzID0gKHJvd0hlaWdodHMsIHRhYmxlSGVpZ2h0V2l0aG91dEdhcHMpID0+IHtcbiAgICBjb25zdCB0b3RhbEhlaWdodCA9IHJvd0hlaWdodHMucmVkdWNlKCh0b3RhbCwgd2lkdGgpID0+IHRvdGFsICsgd2lkdGgsIDApO1xuICAgIGNvbnN0IHJhdGlvID0gdGFibGVIZWlnaHRXaXRob3V0R2FwcyAvIHRvdGFsSGVpZ2h0O1xuICAgIGlmIChyYXRpbyA+IDAuOTkgJiYgcmF0aW8gPD0gMS4wMSlcbiAgICAgICAgcmV0dXJuIHJvd0hlaWdodHM7XG4gICAgcmV0dXJuIHJvd0hlaWdodHMubWFwKHdpZHRoID0+IE1hdGgubWF4KHNpbXBsZVZhbHVlKHdpZHRoICogcmF0aW8pLCAxKSk7XG59O1xubGV0IG1hc2tJZFNyYyA9IDA7XG5leHBvcnQgY29uc3QgU1ZHVGFibGVCYXNlID0gKHRhYmxlUHJvcHNXaXRoU3RhbmRhbG9uZSkgPT4ge1xuICAgIGNvbnN0IHsgc3RhbmRhbG9uZSA9IGZhbHNlLCAuLi50YWJsZVByb3BzIH0gPSB0YWJsZVByb3BzV2l0aFN0YW5kYWxvbmU7XG4gICAgbGV0IHsgcm93cywgd2lkdGggPSA1MDAsIGhlaWdodDogaGVpZ2h0RnJvbVByb3BzLCBkZWZhdWx0Q2VsbFN0eWxlLCBkZWZhdWx0Um93U3R5bGUsIGNvbHVtbldpZHRocywgcm93SGVpZ2h0czogcm93SGVpZ2h0RnJvbVByb3BzLCBzdHlsZSwgY2xhc3NOYW1lLCBkZWZzLCBzdmdBdHRycywgfSA9IHRhYmxlUHJvcHM7XG4gICAgY29uc3QgZGVmYXVsdFN0eWxlRm9yQ2VsbCA9IHBhcnNlRGVmYXVsdENlbGxTdHlsZUJhc2UoZGVmYXVsdENlbGxTdHlsZSk7XG4gICAgY29uc3QgbWF4Q29sdW1ucyA9IE1hdGgubWF4KHJvd3MucmVkdWNlKChtYXgsIHJvdykgPT4gQXJyYXkuaXNBcnJheShyb3cpID8gTWF0aC5tYXgobWF4LCByb3cubGVuZ3RoKSA6IE1hdGgubWF4KG1heCwgZ2V0VG90YWxDZWxscyhyb3cuY2VsbHMpKSwgMCksIDEpO1xuICAgIGNvbnN0IHRhYmxlU3R5bGUgPSBwYXJzZWRUYWJsZVN0eWxlKHN0eWxlKTtcbiAgICBjb25zdCBpc1JvdW5kZWRDb3JuZXIgPSAhISh0YWJsZVN0eWxlLnJ4ICYmIHRhYmxlU3R5bGUucnkpO1xuICAgIGNvbnN0IGFsbENvbEdhcHMgPSAobWF4Q29sdW1ucyAtIDEpICogdGFibGVTdHlsZS5jb2xHYXBzICtcbiAgICAgICAgZ2V0V2lkKHRhYmxlU3R5bGUubWFyZ2lucywgJ2xlZnQnKSArXG4gICAgICAgIGdldFdpZCh0YWJsZVN0eWxlLm1hcmdpbnMsICdyaWdodCcpO1xuICAgIGNvbnN0IGFsbFJvd0dhcHMgPSAocm93cy5sZW5ndGggLSAxKSAqIHRhYmxlU3R5bGUucm93R2FwcyArXG4gICAgICAgIGdldFdpZCh0YWJsZVN0eWxlLm1hcmdpbnMsICd0b3AnKSArXG4gICAgICAgIGdldFdpZCh0YWJsZVN0eWxlLm1hcmdpbnMsICdib3R0b20nKTtcbiAgICBjb25zdCBkZWZhdWx0U3R5bGVGb3JSb3cgPSB7XG4gICAgICAgIGhlaWdodDogMzAsXG4gICAgICAgIC4uLmRlZmF1bHRSb3dTdHlsZSxcbiAgICB9O1xuICAgIGxldCBoZWlnaHQgPSBoZWlnaHRGcm9tUHJvcHMgPz9cbiAgICAgICAgcm93cy5yZWR1Y2UoKGgsIHJvdykgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocm93KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoICsgZGVmYXVsdFN0eWxlRm9yUm93LmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoICsgKHJvdy5zdHlsZT8uaGVpZ2h0ID8/IGRlZmF1bHRTdHlsZUZvclJvdy5oZWlnaHQpO1xuICAgICAgICB9LCAwKSArIGFsbFJvd0dhcHM7XG4gICAgaGVpZ2h0ID0gTWF0aC5tYXgoc2ltcGxlVmFsdWUoaGVpZ2h0KSwgMSk7XG4gICAgd2lkdGggPSBNYXRoLm1heChzaW1wbGVWYWx1ZSh3aWR0aCksIDEpO1xuICAgIGNvbnN0IGNlbGxXaWR0aHMgPSBjb2x1bW5XaWR0aHNcbiAgICAgICAgPyBhZGp1c3RDb2x1bW5XaWR0aHMoY29sdW1uV2lkdGhzLCB3aWR0aCAtIGFsbENvbEdhcHMpXG4gICAgICAgIDogQXJyYXkobWF4Q29sdW1ucykuZmlsbChzaW1wbGVWYWx1ZSgod2lkdGggLSBhbGxDb2xHYXBzKSAvIG1heENvbHVtbnMpKTtcbiAgICBsZXQgcm93SGVpZ2h0cyA9IHJvd0hlaWdodEZyb21Qcm9wcyA/P1xuICAgICAgICByb3dzLm1hcChyb3cgPT4gcm93LnN0eWxlPy5oZWlnaHQgPz8gZGVmYXVsdFN0eWxlRm9yUm93LmhlaWdodCk7XG4gICAgaWYgKGhlaWdodEZyb21Qcm9wcykge1xuICAgICAgICByb3dIZWlnaHRzID0gYWRqdXN0Um93SGVpZ2h0cyhyb3dIZWlnaHRzLCBoZWlnaHRGcm9tUHJvcHMgLSBhbGxSb3dHYXBzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByb3dIZWlnaHRGcm9tUm93U3R5bGUgPSByb3dzW2ldPy5zdHlsZT8uaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHJvd0hlaWdodEZyb21Sb3dTdHlsZSAmJiB0eXBlb2Ygcm93SGVpZ2h0c1tpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByb3dIZWlnaHRzW2ldID0gcm93SGVpZ2h0RnJvbVJvd1N0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNhbGN1bGF0ZWRSb3dzID0gY2FsY3VsYXRlUm93cyhjZWxsV2lkdGhzLCByb3dIZWlnaHRzLCByb3dzLCB0YWJsZVN0eWxlLCB0YWJsZVByb3BzKTtcbiAgICBjb25zdCByb3dzQ29udGVudCA9IGNhbGN1bGF0ZWRSb3dzLm1hcCgocm93LCByb3dJbmRleCkgPT4ge1xuICAgICAgICBjb25zdCByb3dDb250ZW50ID0gW107XG4gICAgICAgIGlmIChyb3cuc3R5bGU/LmJnQ29sb3IpIHtcbiAgICAgICAgICAgIHJvd0NvbnRlbnQucHVzaChlbGVtZW50KCdnJywge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke3Jvdy54fSwgJHtyb3cueX0pYCxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSA/IGAke2NsYXNzTmFtZX0tcm93LSR7cm93SW5kZXh9LXdyYXBwZXJgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSwgRmlsbGVkQXJlYSh7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgPyBgJHtjbGFzc05hbWV9LWZpbGxlZC1hcmVhLWJlaGluZC10YWJsZWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJvdy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHJvdy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgYmdDb2xvcjogcm93LnN0eWxlLmJnQ29sb3IsXG4gICAgICAgICAgICAgICAgYm9yZGVyV2lkdGhzOiByb3cuc3R5bGUuYm9yZGVyV2lkdGhzLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yczogcm93LnN0eWxlLmJvcmRlckNvbG9ycyxcbiAgICAgICAgICAgICAgICBib3JkZXJQYXR0ZXJuczogcm93LnN0eWxlLmJvcmRlclBhdHRlcm5zLFxuICAgICAgICAgICAgICAgIGJvcmRlclNoYXBlczogcm93LnN0eWxlLmJvcmRlclNoYXBlcyxcbiAgICAgICAgICAgICAgICByeDogcm93LnN0eWxlLnJ4LFxuICAgICAgICAgICAgICAgIHJ5OiByb3cuc3R5bGUucnksXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiByb3cuY2VsbHMpIHtcbiAgICAgICAgICAgIHJvd0NvbnRlbnQucHVzaChBQ2VsbCh7XG4gICAgICAgICAgICAgICAgY2VsbE9wdDogY2VsbCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3R5bGU6IGRlZmF1bHRTdHlsZUZvckNlbGwsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQoJ2cnLCB7XG4gICAgICAgICAgICByb2xlOiAncm93JyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYCR7Y2xhc3NOYW1lfS1yb3ctJHtyb3dJbmRleH1gIDogdW5kZWZpbmVkLFxuICAgICAgICB9LCAuLi5yb3dDb250ZW50KTtcbiAgICB9KTtcbiAgICBjb25zdCBwcm9wc0ZvclN2ZyA9IHN0YW5kYWxvbmVcbiAgICAgICAgPyB7XG4gICAgICAgICAgICB4bWxuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICAgICAgICAgIHhtbG5zWGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICB9O1xuICAgIGNvbnN0IG1hc2tOYW1lID0gYHN2Zy10YWJsZS1tYXNrLSR7Y2xhc3NOYW1lfS0ke21hc2tJZFNyYysrICUgMTAwMDAwMDB9YDtcbiAgICByZXR1cm4gZWxlbWVudCgnc3ZnJywge1xuICAgICAgICAuLi5wcm9wc0ZvclN2ZyxcbiAgICAgICAgdmlld0JveDogYDAgMCAke3dpZHRofSAke2hlaWdodH1gLFxuICAgICAgICB4bWxuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgPyBgc3ZnLXRhYmxlICR7Y2xhc3NOYW1lfWAgOiB1bmRlZmluZWQsXG4gICAgICAgIC4uLnN2Z0F0dHJzLFxuICAgICAgICBzdHlsZTogeyBvdmVyZmxvdzogJ3Zpc2libGUnIH0sXG4gICAgfSwgZGVmcyAmJiBlbGVtZW50KCdkZWZzJywge30sIGRlZnMpLCBpc1JvdW5kZWRDb3JuZXIgJiZcbiAgICAgICAgZWxlbWVudCgnbWFzaycsIHtcbiAgICAgICAgICAgIGlkOiBtYXNrTmFtZSxcbiAgICAgICAgfSwgW1xuICAgICAgICAgICAgZWxlbWVudCgncmVjdCcsIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgZmlsbDogJ2JsYWNrJyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZWxlbWVudCgncmVjdCcsIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgcng6IHRhYmxlU3R5bGUucngsXG4gICAgICAgICAgICAgICAgcnk6IHRhYmxlU3R5bGUucnksXG4gICAgICAgICAgICAgICAgZmlsbDogJ3doaXRlJyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdKSwgRmlsbGVkQXJlYSh7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYCR7Y2xhc3NOYW1lfS1maWxsZWQtYXJlYS1iZWhpbmQtdGFibGVgIDogdW5kZWZpbmVkLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBiZ0NvbG9yOiB0YWJsZVN0eWxlLmJnQ29sb3IsXG4gICAgICAgIGJvcmRlcldpZHRoczogdGFibGVTdHlsZS5ib3JkZXJXaWR0aHMsXG4gICAgICAgIGJvcmRlckNvbG9yczogdGFibGVTdHlsZS5ib3JkZXJDb2xvcnMsXG4gICAgICAgIGJvcmRlclBhdHRlcm5zOiB0YWJsZVN0eWxlLmJvcmRlclBhdHRlcm5zLFxuICAgICAgICBib3JkZXJTaGFwZXM6IHRhYmxlU3R5bGUuYm9yZGVyU2hhcGVzLFxuICAgICAgICByeDogdGFibGVTdHlsZS5yeCxcbiAgICAgICAgcnk6IHRhYmxlU3R5bGUucnksXG4gICAgfSksIGVsZW1lbnQoJ2cnLCB7XG4gICAgICAgIHJvbGU6ICd0YWJsZScsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYCR7Y2xhc3NOYW1lfS1jb250ZW50LWFyZWFgIDogdW5kZWZpbmVkLFxuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtnZXRXaWQodGFibGVTdHlsZS5tYXJnaW5zLCAnbGVmdCcpfSAke2dldFdpZCh0YWJsZVN0eWxlLm1hcmdpbnMsICd0b3AnKX0pYCxcbiAgICAgICAgLi4uKGlzUm91bmRlZENvcm5lciA/IHsgbWFzazogYHVybCgjJHttYXNrTmFtZX0pYCB9IDoge30pLFxuICAgIH0sIC4uLnJvd3NDb250ZW50KSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U1ZHVGFibGVCYXNlLmpzLm1hcCIsImltcG9ydCB7IFNWR1RhYmxlQmFzZSB9IGZyb20gJy4vU1ZHVGFibGVCYXNlJztcbmV4cG9ydCAqIGZyb20gJy4vY29tbW9uLXR5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vcHJpdmF0ZS10eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzJztcbmV4cG9ydCAqIGZyb20gJy4vY29uc3RzJztcbmV4cG9ydCB7IFNWR1RhYmxlQmFzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGNvbnN0IGtlYmFiaXplID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoL1tBLVpdKyg/IVthLXpdKXxbQS1aXS9nLCAoJCwgb2ZzKSA9PiAob2ZzID8gJy0nIDogJycpICsgJC50b0xvd2VyQ2FzZSgpKTtcbmNvbnN0IGNvbnZlcnRWYWwgPSAodmFsLCBrZXkpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicgJiYgIXZhbClcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdzb21ldGhpbmcgaXMgd3JvbmcuLiB2YWx1ZSB0eXBlIGNhbm5vdCBiZSBhcnJheScsICdrZXk6Jywga2V5LCAndmFsOicsIHZhbCk7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHZhbClcbiAgICAgICAgICAgIC5tYXAoKFtrLCB2XSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGAke2tlYmFiaXplKGspfToke3Z9YDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCc7Jyk7XG4gICAgfVxuICAgIHJldHVybiBgJHt2YWx9YDtcbn07XG5jb25zdCBjb252ZXJ0QXR0clRvSHRtbFN0eWxlID0gKGF0dHJOYW1lKSA9PiB7XG4gICAgaWYgKGF0dHJOYW1lID09PSAnY2xhc3NOYW1lJylcbiAgICAgICAgcmV0dXJuICdjbGFzcyc7XG4gICAgc3dpdGNoIChhdHRyTmFtZSkge1xuICAgICAgICBjYXNlICd2aWV3Qm94JzpcbiAgICAgICAgICAgIHJldHVybiBhdHRyTmFtZTtcbiAgICB9XG4gICAgaWYgKGF0dHJOYW1lLm1hdGNoKC9bQS1aXSsvKSkge1xuICAgICAgICBjb25zdCBuZXdLZXkgPSBrZWJhYml6ZShhdHRyTmFtZSk7XG4gICAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgfVxuICAgIHJldHVybiBhdHRyTmFtZTtcbn07XG5leHBvcnQgY29uc3QgY29udmVydFRvS2ViYWJDYXNlUHJvcHMgPSAoYXR0cnMpID0+IHtcbiAgICBjb25zdCBrZWJhYkNhc2VQcm9wcyA9IE9iamVjdC5rZXlzKGF0dHJzKS5yZWR1Y2UoKGN1cnIsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBjb252ZXJ0ZWRLZXkgPSBjb252ZXJ0QXR0clRvSHRtbFN0eWxlKGtleSk7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZCA9IGAke2NvbnZlcnRWYWwoYXR0cnNba2V5XSwga2V5KX1gO1xuICAgICAgICBpZiAoIWNvbnZlcnRlZClcbiAgICAgICAgICAgIHJldHVybiBjdXJyO1xuICAgICAgICByZXR1cm4geyAuLi5jdXJyLCBbY29udmVydGVkS2V5XTogY29udmVydGVkIH07XG4gICAgfSwge30pO1xuICAgIHJldHVybiBrZWJhYkNhc2VQcm9wcztcbn07XG5leHBvcnQgY29uc3QgY3JlYXRlVmFuaWxsYUVsZW1lbnQgPSAodHlwZSwgYXR0cnMsIC4uLmNoaWxkcmVuKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX19pbnRlcm5hbDogJ3N2Zy10YWJsZS1lbGVtZW50LWFzLW9iaicsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGF0dHJzLFxuICAgICAgICBjaGlsZHJlbixcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBjcmVhdGVSZW5kZXJlZFN0cmluZyA9ICguLi5yZW5kZXJlZEh0bWwpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBfX2ludGVybmFsOiAnc3ZnLXRhYmxlLXJlbmRlcmVkLXRleHQnLFxuICAgICAgICB0eXBlOiAnZycsXG4gICAgICAgIGF0dHJzOiB7fSxcbiAgICAgICAgY2hpbGRyZW46IFtyZW5kZXJlZEh0bWwuam9pbignJyldLFxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IF9fcHJpdmF0ZV9fID0ge1xuICAgIGNvbnZlcnRWYWwsXG4gICAgY29udmVydEF0dHJUb0h0bWxTdHlsZSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBjb252ZXJ0VG9LZWJhYkNhc2VQcm9wcyB9IGZyb20gJy4vdXRpbHMnO1xuZXhwb3J0IGNvbnN0IHN2Z0NvbnZlcnRlciA9IChlbGVtZW50KSA9PiB7XG4gICAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQubWFwKGMgPT4gc3ZnQ29udmVydGVyKGMpKS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgIT09ICdudW1iZXInICYmICFlbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICByZXR1cm4gc3ZnQ29udmVydGVyKGVsZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBlbCA9IGVsZW1lbnQ7XG4gICAgaWYgKGVsLnR5cGUgJiYgZWwuYXR0cnMgJiYgZWwuX19pbnRlcm5hbCA9PT0gJ3N2Zy10YWJsZS1lbGVtZW50LWFzLW9iaicpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0eXBlb2YgZWwuY2hpbGRyZW4gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IGVsLmNoaWxkcmVuXG4gICAgICAgICAgICA6IGVsLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgPyBlbC5jaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICAubWFwKGMgPT4gKHR5cGVvZiBjID09PSAnYm9vbGVhbicgJiYgIWMgPyBudWxsIDogc3ZnQ29udmVydGVyKGMpKSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcih2ID0+IHYpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKVxuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgIGNvbnN0IGtlYmFiQ2FzZVByb3BzID0gY29udmVydFRvS2ViYWJDYXNlUHJvcHMoZWwuYXR0cnMpO1xuICAgICAgICBjb25zdCBhdHRycyA9IE9iamVjdC5lbnRyaWVzKGtlYmFiQ2FzZVByb3BzKVxuICAgICAgICAgICAgLm1hcChlbnRyeSA9PiB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCB2YWxdID0gZW50cnk7XG4gICAgICAgICAgICByZXR1cm4gYCR7a2V5fT1cIiR7dmFsfVwiYDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIodiA9PiB2KVxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgcmV0dXJuIGA8JHtlbC50eXBlfSAke2F0dHJzfT4ke2NoaWxkcmVufTwvJHtlbC50eXBlfT5gO1xuICAgIH1cbiAgICBpZiAoZWwuX19pbnRlcm5hbCA9PT0gJ3N2Zy10YWJsZS1yZW5kZXJlZC10ZXh0Jykge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHR5cGVvZiBlbC5jaGlsZHJlbiA9PT0gJ3N0cmluZycgPyBlbC5jaGlsZHJlbiA6IGVsLmNoaWxkcmVuID8gZWwuY2hpbGRyZW4uZmlsdGVyKHYgPT4gdikuam9pbignXFxuJykgOiAnJztcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudC5vdXRlckhUTUw7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ZnQ29udmVydGVyLmpzLm1hcCIsImltcG9ydCB7IFNWR1RhYmxlQmFzZSB9IGZyb20gJ0BzaGplb24wNzMwL3N2Zy10YWJsZS1jb3JlJztcbmltcG9ydCB7IHN2Z0NvbnZlcnRlciB9IGZyb20gJy4vc3ZnQ29udmVydGVyJztcbmV4cG9ydCBjb25zdCBTVkdUYWJsZSA9ICh0YWJsZVByb3BzKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IFNWR1RhYmxlQmFzZSh0YWJsZVByb3BzKTtcbiAgICByZXR1cm4gc3ZnQ29udmVydGVyKGVsZW1lbnQpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNWR1RhYmxlLmpzLm1hcCIsImltcG9ydCB7IFNWR1RhYmxlIH0gZnJvbSAnLi9TVkdUYWJsZSc7XG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCB7IHNpbXBsZVZhbHVlIH0gZnJvbSAnQHNoamVvbjA3MzAvc3ZnLXRhYmxlLWNvcmUnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscyc7XG5leHBvcnQgZGVmYXVsdCBTVkdUYWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8vIEB0cy1pZ25vcmVcbmV4cG9ydCAqIGZyb20gXCJAc2hqZW9uMDczMC9zdmctdGFibGUtdmFuaWxsYVwiO1xuLy8gQHRzLWlnbm9yZVxuZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCJAc2hqZW9uMDczMC9zdmctdGFibGUtdmFuaWxsYVwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9