/******/ // The require scope
/******/ var __webpack_require__ = {};
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Ee": () => (/* reexport */ __private__),
  "nI": () => (/* reexport */ convertToKebabCaseProps),
  "V6": () => (/* reexport */ createRenderedString),
  "CK": () => (/* reexport */ createVanillaElement),
  "ZP": () => (/* reexport */ dist),
  "iS": () => (/* reexport */ kebabize),
  "s1": () => (/* reexport */ simpleValue)
});

;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/consts.js
const INTERNAL_CSS_VARS = Object.freeze({
    borderLineColor: '--line-default-stroke',
    textColor: '--text-default-color',
});
const DEFAULT_COLORS = Object.freeze({
    border: '#000',
});
const DEFAULT_WITH_CSSVARS = Object.freeze({
    border: `var(${INTERNAL_CSS_VARS.borderLineColor}, ${DEFAULT_COLORS.border})`,
});
//# sourceMappingURL=consts.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/utils.js

const getValFromArr = (arr, pos) => {
    if (arr.length === 4) {
        switch (pos) {
            case 'left':
                return arr[3];
            case 'right':
                return arr[1];
            case 'bottom':
                return arr[2];
            default:
            case 'top':
                return arr[0];
        }
    }
    else if (arr.length === 2) {
        switch (pos) {
            case 'left':
                return arr[1];
            case 'right':
                return arr[1];
            case 'top':
            case 'bottom':
            default:
                return arr[0];
        }
    }
    return;
};
const getWid = (widths, pos) => {
    if (widths === undefined)
        return 0;
    if (typeof widths === 'number')
        return widths;
    if (Array.isArray(widths)) {
        const val = getValFromArr(widths, pos);
        if (val !== undefined)
            return val;
    }
    console.error('Invalid widths type: ', widths, 'for', pos, ' should be number or [number, number, number, number] or [number, number]');
    return 0;
};
const getWidVisible = (widths) => {
    if (widths === undefined)
        return false;
    if (typeof widths === 'number')
        return widths > 0;
    if (Array.isArray(widths)) {
        return widths.some(w => w > 0);
    }
    return false;
};
const getStrokeColor = (colors, pos) => {
    if (!colors)
        return undefined;
    if (typeof colors === 'string')
        return colors;
    if (Array.isArray(colors)) {
        if (pos) {
            const val = getValFromArr(colors, pos);
            if (val !== undefined)
                return val;
        }
        else {
            return (colors && Array.isArray(colors) ? colors[0] : colors) ?? DEFAULT_WITH_CSSVARS.border;
        }
    }
    console.error('Invalid colors type: ', colors, ' should be string or [string, string, string, string] or [string, string]');
    return DEFAULT_WITH_CSSVARS.border;
};
const isValidateArrayType = (arr, type) => {
    return Array.isArray(arr) && arr.every(item => typeof item === type);
};
const isValidate2DArrayType = (arr, type) => {
    return (Array.isArray(arr) &&
        arr.every(item => {
            return Array.isArray(item) && isValidateArrayType(item, type);
        }));
};
const getDashArray = (dashArrays, pos) => {
    if (dashArrays === undefined)
        return undefined;
    if (isValidateArrayType(dashArrays, 'number')) {
        return dashArrays.map(a => a.toString()).join(' ');
    }
    if (isValidate2DArrayType(dashArrays, 'number')) {
        const arr = dashArrays;
        const val = getValFromArr(arr, pos);
        if (val !== undefined)
            return val.map(a => a.toString()).join(' ');
    }
    console.error('Invalid dashArrays type: ', dashArrays, ' should be number[] or [number[], number[], number[], number[]] or [number[], number[]]');
    return undefined;
};
const validatedBorderShape = (borderShape, dashArrays) => {
    if (!dashArrays && !borderShape)
        return undefined;
    if (!dashArrays) {
        console.warn('border shape does not have any effect without dash arrays. automatically ignoring it.');
        return undefined;
    }
    if (!borderShape || borderShape === 'butt') {
        const dashArrs = dashArrays.split(' ');
        if (dashArrs.some((val, idx) => val === '0' && idx % 2 === 0)) {
            console.error('"butt" border shape(or undefined - default) will not be shown with 0 size. in odd order. i.e. stroke-dasharray="0 1" will not be shown since the first value is 0.', '\n\nyour dash array:', dashArrays);
        }
    }
    return borderShape;
};
const getBorderShape = (borderShapes, dashArrays, pos) => {
    if (!borderShapes)
        return validatedBorderShape(borderShapes, getDashArray(dashArrays, pos));
    if (typeof borderShapes === 'string')
        return validatedBorderShape(borderShapes, getDashArray(dashArrays, pos));
    if (Array.isArray(borderShapes)) {
        const val = getValFromArr(borderShapes, pos);
        if (val !== undefined) {
            return validatedBorderShape(val, getDashArray(dashArrays, pos));
        }
    }
    console.error('Invalid borderShapes type: ', borderShapes, ' should be string or [string, string, string, string] or [string, string]');
    return 'butt';
};
const isBorderRect = (style) => {
    const { borderWidths, borderColors, borderPatterns, bgColor, rx, ry } = style;
    if (!bgColor)
        return false;
    return ((!rx || typeof rx === 'number') &&
        (!ry || typeof ry === 'number') &&
        (!borderWidths || typeof borderWidths === 'number') &&
        (!borderColors || typeof borderColors === 'string') &&
        (!borderPatterns || (Array.isArray(borderPatterns) && typeof borderPatterns[0] === 'number')));
};
const getRectStyle = (style) => {
    if (!isBorderRect(style))
        return null;
    const { bgColor, borderWidths, borderColors, borderPatterns, rx, ry } = style;
    return {
        ...(bgColor ? { fill: bgColor } : {}),
        ...(rx || ry ? { rx: rx ?? 0, ry: ry ?? 0 } : {}),
        stroke: (borderColors ?? DEFAULT_WITH_CSSVARS.border),
        strokeWidth: borderWidths,
        strokeDasharray: getDashArray(borderPatterns, 'left'),
    };
};
const simpleValue = (val) => {
    return parseFloat(val.toFixed(2));
};
const camelToKebabCase = (str) => str.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`);
const kebabToCamelCase = (str) => str
    .split('-')
    .map((v, i) => (i === 0 ? v : v[0]?.toUpperCase() + v.substring(1)))
    .join('');
const getDuplicatedProps = (attr) => {
    Object.keys(attr).forEach(key => {
        attr[camelToKebabCase(key)] = attr[key];
    });
    Object.keys(attr).forEach(key => {
        attr[kebabToCamelCase(key)] = attr[key];
    });
};
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/element.js
const element_element = (type, attrs, ...children) => {
    const validChildren = children.filter(child => child !== undefined && child !== null);
    return Object.keys(attrs).length > 0 || validChildren.length > 0
        ? {
            __internal: 'svg-table-element-as-obj',
            type,
            attrs,
            children: validChildren.length > 0 && Array.isArray(validChildren[0]) ? validChildren[0] : validChildren,
        }
        : undefined;
};
//# sourceMappingURL=element.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/PathOnArea.js


const Path = ({ startPt, endPt, width, borderColors, borderPatterns, borderShapes, pos, className, }) => {
    if (width === 0)
        return null;
    return element_element('path', {
        className: className ? `${pos}-path` : undefined,
        d: `M${startPt} L${endPt}`,
        strokeWidth: width,
        stroke: getStrokeColor(borderColors, pos),
        strokeDasharray: getDashArray(borderPatterns, pos),
        strokeLinecap: getBorderShape(borderShapes, borderPatterns, pos),
    });
};
const getPt = (x, y) => `${x},${y}`;
const PathOnArea = (props) => {
    const { width, height, borderWidths, borderColors, borderPatterns, borderShapes, className, rx = 0, ry = 0, } = props;
    const PathProps = {
        borderColors,
        borderPatterns,
        borderShapes,
    };
    const cornerExist = rx && ry;
    const leftTop = getPt(0, 0);
    const leftBottom = getPt(0, height - 0);
    const rightTop = getPt(width - 0, 0);
    const rightBottom = getPt(width - 0, height - 0);
    if (cornerExist) {
        const width = (borderWidths && Array.isArray(borderWidths) ? borderWidths[0] : borderWidths) ?? 0;
        if (!width)
            return null;
        const leftLineTop = getPt(0, ry);
        const leftLineBottom = getPt(0, height - ry);
        const topLineLeft = getPt(rx, 0);
        const topLineRight = getPt(width - rx, 0);
        const rightLineTop = getPt(width, ry);
        const rightLineBottom = getPt(width, height - ry);
        const bottomLineLeft = getPt(rx, height);
        const bottomLineRight = getPt(width - rx, height);
        return element_element('g', {
            className: className ? `paths-on-area ${className}` : undefined,
        }, element_element('path', {
            className: className ? `${className}-corner-path` : undefined,
            d: `M${leftLineTop} Q${leftTop},${topLineLeft} L${topLineRight} Q${rightTop},${rightLineTop} L${rightLineBottom} Q${rightBottom},${bottomLineRight} L${bottomLineLeft} Q${leftBottom},${leftLineBottom} L${leftLineTop}`,
            strokeWidth: width,
            stroke: getStrokeColor(borderColors),
            strokeDasharray: getDashArray(borderPatterns),
            strokeLinecap: getBorderShape(borderShapes, borderPatterns),
        }));
    }
    else {
        const leftWid = getWid(borderWidths, 'left');
        const rightWid = getWid(borderWidths, 'right');
        const topWid = getWid(borderWidths, 'top');
        const bottomWid = getWid(borderWidths, 'bottom');
        return element_element('g', {
            className: className ? `paths-on-area ${className}` : undefined,
        }, !!leftWid &&
            Path({
                startPt: leftTop,
                endPt: leftBottom,
                width: leftWid,
                ...PathProps,
                pos: 'left',
            }), !!rightWid &&
            Path({
                startPt: rightTop,
                endPt: rightBottom,
                width: rightWid,
                ...PathProps,
                pos: 'right',
            }), !!topWid &&
            Path({
                startPt: leftTop,
                endPt: rightTop,
                width: topWid,
                ...PathProps,
                pos: 'top',
            }), !!bottomWid &&
            Path({
                startPt: leftBottom,
                endPt: rightBottom,
                width: bottomWid,
                ...PathProps,
                pos: 'bottom',
            }));
    }
};
//# sourceMappingURL=PathOnArea.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/FilledArea.js



const FilledArea = (props) => {
    const { bgColor, width, height, borderWidths, borderColors, borderPatterns, borderShapes, className, rx, ry } = props;
    const isBgColorVisible = bgColor && bgColor !== 'transparent';
    const isBorderOnRect = isBgColorVisible && isBorderRect(props);
    const rectStyleProps = isBorderOnRect ? getRectStyle(props) : { fill: bgColor };
    const isFilledAreaVisible = isBgColorVisible || getWidVisible(borderWidths);
    return isFilledAreaVisible
        ? element_element('g', {
            className: className ? `filled-area ${className ?? ''}` : undefined,
        }, isBgColorVisible &&
            element_element('rect', {
                width: width,
                height: height,
                ...rectStyleProps,
            }), !isBorderOnRect &&
            PathOnArea({
                className: className ? 'paths-on-area-for-filled-area' : undefined,
                width: width,
                height: height,
                borderWidths: borderWidths,
                borderColors: borderColors,
                borderPatterns: borderPatterns,
                borderShapes: borderShapes,
                rx,
                ry,
            }))
        : undefined;
};
/* harmony default export */ const dist_FilledArea = (FilledArea);
//# sourceMappingURL=FilledArea.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/CenteredCellContent.js


const CenteredCellContent = ({ cellOpt, styleToUse, children, }) => {
    let { width, height, className } = cellOpt;
    let { rotateCenterProps, cx = 0, cy = 0 } = styleToUse;
    const propsToPassForGroup = (startX, startY) => ({
        x: simpleValue(startX),
        y: simpleValue(startY),
        width,
        height,
    });
    const rotationGroupProps = {
        ...(typeof rotateCenterProps === 'function'
            ? rotateCenterProps(propsToPassForGroup(width / 2 + cx, height / 2 + cy))
            : rotateCenterProps),
    };
    getDuplicatedProps(rotationGroupProps);
    width = Math.max(width, 1);
    height = Math.max(height, 1);
    return element_element('svg', {
        viewBox: `${-width / 2} ${-height / 2} ${width} ${height}`,
        style: { overflow: 'visible' },
    }, element_element('g', {
        className: className ? `${className}-content` : undefined,
    }, element_element('g', rotationGroupProps, children)));
};
//# sourceMappingURL=CenteredCellContent.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/ACell.js





const moveToLeftTop = (width, height, content) => {
    return element_element('g', {
        transform: `translate(${-width / 2}, ${-height / 2})`,
    }, content);
};
const convertToTableIfNeeded = (contentTouse, width, height, paddings, cellOpt) => {
    if (contentTouse.table) {
        const padLeft = getWid(paddings, 'left');
        const padTop = getWid(paddings, 'top');
        const padRight = getWid(paddings, 'right');
        const padBottom = getWid(paddings, 'bottom');
        const tableWid = simpleValue(width - padRight - padLeft);
        const adjustProps = cellOpt._heightAdjust
            ? {
                height: simpleValue(Math.max(height - padTop - padBottom, 1)),
            }
            : {};
        if (cellOpt._standalone)
            adjustProps.standalone = true;
        return SVGTableBase({
            width: simpleValue(tableWid),
            ...adjustProps,
            ...contentTouse.table,
        });
    }
    return contentTouse;
};
const renderTextOnly = (contentToRender, startX, startY, textAnchor, styleToApply = {}) => {
    const lines = contentToRender.split('\n');
    let textToRender = [contentToRender];
    if (lines.length > 1) {
        const fontSize = styleToApply.fontSize || 16;
        textToRender = lines
            .filter(v => v)
            .map((line, index) => element_element('tspan', {
            fontSize,
            x: startX,
            dy: index === 0 ? 0 : fontSize,
        }, line));
        startY = startY - ((lines.length - 1) * simpleValue(fontSize)) / 2;
    }
    const props = {
        x: simpleValue(startX),
        y: simpleValue(startY),
        textAnchor: textAnchor,
        dominantBaseline: 'middle',
        ...styleToApply,
    };
    getDuplicatedProps(props);
    return element_element('text', props, ...textToRender);
};
const styleWithFill = (style, color) => {
    return {
        fill: color,
        ...style,
    };
};
const getAriaProps = (cellOpt) => {
    return JSON.parse(JSON.stringify({
        'aria-colspan': cellOpt.colSpan && cellOpt.colSpan > 1 ? cellOpt.colSpan : undefined,
        'aria-rowspan': cellOpt.rowSpan && cellOpt.rowSpan > 1 ? cellOpt.rowSpan : undefined,
    }));
};
const getContents = (cellOpt, styleToUse) => {
    const { content, width, height, before, after } = cellOpt;
    let { paddings, textColor, textStyle, cx = 0, cy = 0 } = styleToUse;
    textStyle = styleWithFill(textStyle, textColor);
    const { content: before2, ...beforeOpts } = typeof before === 'object' && before.content
        ? before
        : { content: before };
    const { content: after2, ...afterOpts } = typeof after === 'object' && after.content
        ? after
        : { content: after };
    const beforeTextStyle = styleWithFill(beforeOpts.textStyle, textColor);
    const afterTextStyle = styleWithFill(afterOpts.textStyle, textColor);
    const propsToPass = (textStyleToUse, anchorBase, startX, startY) => ({
        x: simpleValue(startX),
        y: simpleValue(startY),
        width,
        height,
        textColor,
        textStyle: {
            textAnchor: anchorBase,
            dominantBaseline: 'middle',
            ...textStyleToUse,
        },
    });
    const getContent = () => {
        if (typeof content === 'function') {
            let node = content(propsToPass(textStyle, 'middle', width / 2 + cx, height / 2 + cy));
            return node;
        }
        else if (typeof content === 'object') {
            const node = convertToTableIfNeeded(content, width, height, paddings, cellOpt);
            return node;
        }
        else {
            return content;
        }
    };
    const contentToUse = getContent();
    let beforeToUse = typeof before2 === 'function' ? before2(propsToPass(beforeTextStyle, 'start', 0, height / 2)) : before2;
    let afterToUse = typeof after2 === 'function' ? after2(propsToPass(afterTextStyle, 'end', width, height / 2)) : after2;
    const beforeContent = beforeToUse && typeof beforeToUse === 'string'
        ? renderTextOnly(beforeToUse, 0, height / 2, 'start', beforeTextStyle)
        : beforeToUse;
    const afterContent = afterToUse && typeof afterToUse === 'string'
        ? renderTextOnly(afterToUse, width, height / 2, 'end', afterTextStyle)
        : afterToUse;
    const mainContent = typeof contentToUse === 'string'
        ? renderTextOnly(contentToUse, cx, cy, 'middle', textStyle)
        : moveToLeftTop(width, height, contentToUse);
    return {
        beforeContent,
        afterContent,
        mainContent,
    };
};
const FilledAreaInCell = ({ cellOpt, styleToUse, }) => {
    const { width, height, className } = cellOpt;
    let { bgColor, borderWidths, borderColors, borderPatterns, borderShapes, rx, ry } = styleToUse;
    return dist_FilledArea({
        className: className ? `${className}-filled-back` : undefined,
        width: width,
        height: height,
        borderWidths: borderWidths,
        borderColors: borderColors,
        borderPatterns: borderPatterns,
        borderShapes: borderShapes,
        rx,
        ry,
        ...(bgColor ? { bgColor } : {}),
    });
};
const ACell = ({ cellOpt, defaultStyle, }) => {
    if (cellOpt._ignored)
        return null;
    let { x, y, width, height, style, className } = cellOpt;
    const styleToUse = {
        ...defaultStyle,
        ...style,
    };
    let { paddings, svgStyle, allowOverflow } = styleToUse;
    const padLeft = getWid(paddings, 'left');
    const padTop = getWid(paddings, 'top');
    const svgStyleToUse = {
        ...svgStyle,
        ...(allowOverflow ? { overflow: 'visible' } : {}),
    };
    const ariaProps = getAriaProps(cellOpt);
    const { beforeContent, afterContent, mainContent } = getContents(cellOpt, styleToUse);
    width = Math.max(width, 1);
    height = Math.max(height, 1);
    return element_element('g', {
        transform: `translate(${x}, ${y})`,
        className: className ? `${className}-wrapper` : undefined,
    }, FilledAreaInCell({ cellOpt: cellOpt, styleToUse: styleToUse }), element_element('svg', {
        width: width,
        height: height,
        style: svgStyleToUse,
        viewBox: `0 0 ${width} ${height}`,
        className: className ? className : undefined,
    }, element_element('g', {
        transform: `translate(${padLeft}, ${padTop})`,
        className: className ? `${className}-padding` : undefined,
        role: 'cell',
        ...ariaProps,
    }, beforeContent, CenteredCellContent({
        cellOpt: cellOpt,
        styleToUse: styleToUse,
        children: mainContent,
    }), afterContent)));
};
//# sourceMappingURL=ACell.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/calculateRows.js

let debugObj = {};
const getCellWidth = (cellWidths, startCol, colSpan, colGap) => {
    if (cellWidths.length < startCol + colSpan - 1) {
        console.error('Not enough column widths provided. check colSpan of the cell data. startCol: ' + startCol, 'data is:', JSON.parse(JSON.stringify(debugObj)));
    }
    return simpleValue(cellWidths.slice(startCol, startCol + colSpan).reduce((total, width) => total + width, 0) +
        colGap * (colSpan - 1));
};
const getCellHeight = (rowHeights, startRow, rowSpan, rowGap) => {
    if (rowHeights.length < startRow + rowSpan - 1) {
        console.error('Not enough row heights provided. check rowSpan of the cell data. startRow: ' + startRow, 'data is:', JSON.parse(JSON.stringify(debugObj)));
    }
    return (rowHeights.slice(startRow, startRow + rowSpan).reduce((total, height) => total + height, 0) +
        rowGap * (rowSpan - 1));
};
const insertIgnoredCell = (row, colIndex, cell) => {
    row.cells = [
        ...(row.cells.slice(0, colIndex) ?? []),
        ...Array(cell.colSpan ?? 1)
            .fill(null)
            .map(() => ({
            _ignored: true,
            colSpan: 1,
        })),
        ...(row.cells.slice(colIndex) ?? []),
    ];
};
const calculateRows = (cellWidths, rowHeights, rows, style, tableProps) => {
    let currentY = 0;
    const embededTableHeightAdjust = !!tableProps.height;
    const standaloneTable = !!tableProps.standalone;
    const calcRows = rows.map(aRow => {
        const row = Array.isArray(aRow) ? { cells: aRow } : aRow;
        return {
            ...row,
            x: 0,
            y: currentY,
            height: -1,
            width: -1,
            cells: [
                ...row.cells.map(aCell => {
                    const cell = typeof aCell === 'string' ? { content: aCell } : aCell;
                    return {
                        ...cell,
                        x: -1,
                        y: -1,
                        height: -1,
                        width: -1,
                        _ignored: false,
                        _heightAdjust: embededTableHeightAdjust,
                        _standalone: standaloneTable,
                    };
                }),
            ],
        };
    });
    for (let ri = 0; ri < calcRows.length; ri++) {
        const row = calcRows[ri];
        if (!row)
            continue;
        let currentX = 0;
        let idx = 0;
        for (const cell of row.cells) {
            debugObj = {
                row: row,
                cell: cell,
            };
            if (cell._ignored) {
                const widToSkip = getCellWidth(cellWidths, idx, 1, style?.colGaps ?? 0);
                idx += 1;
                currentX += widToSkip + (style?.colGaps ?? 0);
                continue;
            }
            const isLastCellButNotLastColumn = row.cells[row.cells.length - 1] === cell && idx !== cellWidths.length - 1;
            const colSpan = isLastCellButNotLastColumn ? cellWidths.length - idx : 1;
            cell.colSpan = colSpan;
            const cellWidth = getCellWidth(cellWidths, idx, cell.colSpan, style?.colGaps ?? 0);
            if (cell.rowSpan) {
                for (let i = 1; i < cell.rowSpan; i++) {
                    if (calcRows[ri + i]) {
                        insertIgnoredCell(calcRows[ri + i], idx, cell);
                    }
                    else {
                        console.error('row is not found at index: ' + (idx + i), 'your cell is:', cell, 'your rows are', calcRows, 'idx is', idx);
                    }
                }
            }
            cell.width = cellWidth;
            cell.height = getCellHeight(rowHeights, ri, cell.rowSpan ?? 1, style?.rowGaps ?? 0);
            cell.x = simpleValue(currentX);
            cell.y = simpleValue(currentY);
            currentX += cellWidth + (style?.colGaps ?? 0);
            idx += 1;
        }
        currentY += (rowHeights[ri] ?? 0) + (style?.rowGaps ?? 0);
        row.height = currentY;
        row.width = currentX;
    }
    return calcRows;
};
//# sourceMappingURL=calculateRows.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/SVGTableBase.js






const getTotalCells = (cells) => {
    return cells.reduce((total, cell) => {
        const cellAsObj = cell;
        if (typeof cellAsObj === 'object' && cellAsObj.colSpan) {
            return total + cellAsObj.colSpan;
        }
        return total + 1;
    }, 0);
};
const parsedTableStyle = (style) => {
    return {
        rowGaps: 0,
        colGaps: 0,
        borderWidths: undefined,
        borderPatterns: undefined,
        borderShapes: undefined,
        borderColors: style?.borderWidths ? `var(${INTERNAL_CSS_VARS.borderLineColor}, #000)` : undefined,
        svgStyle: { overflow: 'visible' },
        ...style,
        margins: style?.margins ?? 0,
    };
};
const parseDefaultCellStyleBase = (defaultCellStyleBase) => {
    return {
        allowOverflow: false,
        borderWidths: 1,
        bgColor: undefined,
        textStyle: undefined,
        borderColors: `var(${INTERNAL_CSS_VARS.borderLineColor}, #000)`,
        borderPatterns: undefined,
        borderShapes: undefined,
        paddings: [1, 1, 1, 1],
        textColor: `var(${INTERNAL_CSS_VARS.textColor}, #000)`,
        ...defaultCellStyleBase,
        onlyInnerBorders: defaultCellStyleBase?.rx && defaultCellStyleBase?.ry
            ? true
            : (defaultCellStyleBase?.onlyInnerBorders ?? false),
    };
};
const adjustColumnWidths = (columnWidths, tableWidthWithoutGaps) => {
    const totalWidth = columnWidths.reduce((total, width) => total + width, 0);
    const ratio = tableWidthWithoutGaps / totalWidth;
    if (ratio > 0.99 && ratio <= 1.01)
        return columnWidths;
    return columnWidths.map(width => Math.max(simpleValue(width * ratio), 1));
};
const adjustRowHeights = (rowHeights, tableHeightWithoutGaps) => {
    const totalHeight = rowHeights.reduce((total, width) => total + width, 0);
    const ratio = tableHeightWithoutGaps / totalHeight;
    if (ratio > 0.99 && ratio <= 1.01)
        return rowHeights;
    return rowHeights.map(width => Math.max(simpleValue(width * ratio), 1));
};
let maskIdSrc = 0;
const SVGTableBase = (tablePropsWithStandalone) => {
    const { standalone = false, ...tableProps } = tablePropsWithStandalone;
    let { rows, width = 500, height: heightFromProps, defaultCellStyle, defaultRowStyle, columnWidths, rowHeights: rowHeightFromProps, style, className, defs, svgAttrs, } = tableProps;
    const defaultStyleForCell = parseDefaultCellStyleBase(defaultCellStyle);
    const maxColumns = Math.max(rows.reduce((max, row) => Array.isArray(row) ? Math.max(max, row.length) : Math.max(max, getTotalCells(row.cells)), 0), 1);
    const tableStyle = parsedTableStyle(style);
    const isRoundedCorner = !!(tableStyle.rx && tableStyle.ry);
    const allColGaps = (maxColumns - 1) * tableStyle.colGaps +
        getWid(tableStyle.margins, 'left') +
        getWid(tableStyle.margins, 'right');
    const allRowGaps = (rows.length - 1) * tableStyle.rowGaps +
        getWid(tableStyle.margins, 'top') +
        getWid(tableStyle.margins, 'bottom');
    const defaultStyleForRow = {
        height: 30,
        ...defaultRowStyle,
    };
    let height = heightFromProps ??
        rows.reduce((h, row) => {
            if (Array.isArray(row)) {
                return h + defaultStyleForRow.height;
            }
            return h + (row.style?.height ?? defaultStyleForRow.height);
        }, 0) + allRowGaps;
    height = Math.max(simpleValue(height), 1);
    width = Math.max(simpleValue(width), 1);
    const cellWidths = columnWidths
        ? adjustColumnWidths(columnWidths, width - allColGaps)
        : Array(maxColumns).fill(simpleValue((width - allColGaps) / maxColumns));
    let rowHeights = rowHeightFromProps ??
        rows.map(row => row.style?.height ?? defaultStyleForRow.height);
    if (heightFromProps) {
        rowHeights = adjustRowHeights(rowHeights, heightFromProps - allRowGaps);
        for (let i = 0; i < rows.length; i++) {
            const rowHeightFromRowStyle = rows[i]?.style?.height;
            if (rowHeightFromRowStyle && typeof rowHeights[i] === 'number') {
                rowHeights[i] = rowHeightFromRowStyle;
            }
        }
    }
    const calculatedRows = calculateRows(cellWidths, rowHeights, rows, tableStyle, tableProps);
    const rowsContent = calculatedRows.map((row, rowIndex) => {
        const rowContent = [];
        if (row.style?.bgColor) {
            rowContent.push(element_element('g', {
                transform: `translate(${row.x}, ${row.y})`,
                className: className ? `${className}-row-${rowIndex}-wrapper` : undefined,
            }, dist_FilledArea({
                className: className ? `${className}-filled-area-behind-table` : undefined,
                width: row.width,
                height: row.height,
                bgColor: row.style.bgColor,
                borderWidths: row.style.borderWidths,
                borderColors: row.style.borderColors,
                borderPatterns: row.style.borderPatterns,
                borderShapes: row.style.borderShapes,
                rx: row.style.rx,
                ry: row.style.ry,
            })));
        }
        for (const cell of row.cells) {
            rowContent.push(ACell({
                cellOpt: cell,
                defaultStyle: defaultStyleForCell,
            }));
        }
        return element_element('g', {
            role: 'row',
            className: className ? `${className}-row-${rowIndex}` : undefined,
        }, ...rowContent);
    });
    const propsForSvg = standalone
        ? {
            xmlns: 'http://www.w3.org/2000/svg',
            xmlnsXlink: 'http://www.w3.org/1999/xlink',
        }
        : {
            width,
            height,
        };
    const maskName = `svg-table-mask-${className}-${maskIdSrc++ % 10000000}`;
    return element_element('svg', {
        ...propsForSvg,
        viewBox: `0 0 ${width} ${height}`,
        xmlns: 'http://www.w3.org/2000/svg',
        className: className ? `svg-table ${className}` : undefined,
        ...svgAttrs,
        style: { overflow: 'visible' },
    }, defs && element_element('defs', {}, defs), isRoundedCorner &&
        element_element('mask', {
            id: maskName,
        }, [
            element_element('rect', {
                width: width,
                height: height,
                fill: 'black',
            }),
            element_element('rect', {
                width: width,
                height: height,
                rx: tableStyle.rx,
                ry: tableStyle.ry,
                fill: 'white',
            }),
        ]), dist_FilledArea({
        className: className ? `${className}-filled-area-behind-table` : undefined,
        width: width,
        height: height,
        bgColor: tableStyle.bgColor,
        borderWidths: tableStyle.borderWidths,
        borderColors: tableStyle.borderColors,
        borderPatterns: tableStyle.borderPatterns,
        borderShapes: tableStyle.borderShapes,
        rx: tableStyle.rx,
        ry: tableStyle.ry,
    }), element_element('g', {
        role: 'table',
        className: className ? `${className}-content-area` : undefined,
        transform: `translate(${getWid(tableStyle.margins, 'left')} ${getWid(tableStyle.margins, 'top')})`,
        ...(isRoundedCorner ? { mask: `url(#${maskName})` } : {}),
    }, ...rowsContent));
};
//# sourceMappingURL=SVGTableBase.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-core/dist/index.js






//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-vanilla/dist/utils.js
const kebabize = (str) => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());
const convertVal = (val, key) => {
    if (typeof val !== 'number' && !val)
        return '';
    if (typeof val === 'object') {
        if (Array.isArray(val)) {
            console.error('something is wrong.. value type cannot be array', 'key:', key, 'val:', val);
            return '';
        }
        return Object.entries(val)
            .map(([k, v]) => {
            return `${kebabize(k)}:${v}`;
        })
            .join(';');
    }
    return `${val}`;
};
const convertAttrToHtmlStyle = (attrName) => {
    if (attrName === 'className')
        return 'class';
    switch (attrName) {
        case 'viewBox':
            return attrName;
    }
    if (attrName.match(/[A-Z]+/)) {
        const newKey = kebabize(attrName);
        return newKey;
    }
    return attrName;
};
const convertToKebabCaseProps = (attrs) => {
    const kebabCaseProps = Object.keys(attrs).reduce((curr, key) => {
        const convertedKey = convertAttrToHtmlStyle(key);
        const converted = `${convertVal(attrs[key], key)}`;
        if (!converted)
            return curr;
        return { ...curr, [convertedKey]: converted };
    }, {});
    return kebabCaseProps;
};
const createVanillaElement = (type, attrs, ...children) => {
    return {
        __internal: 'svg-table-element-as-obj',
        type,
        attrs,
        children,
    };
};
const createRenderedString = (...renderedHtml) => {
    return {
        __internal: 'svg-table-rendered-text',
        type: 'g',
        attrs: {},
        children: [renderedHtml.join('')],
    };
};
const __private__ = {
    convertVal,
    convertAttrToHtmlStyle,
};
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-vanilla/dist/svgConverter.js

const svgConverter = (element) => {
    if (element === null || element === undefined)
        return '';
    if (typeof element === 'string')
        return element;
    if (Array.isArray(element)) {
        return element.map(c => svgConverter(c)).join('\n');
    }
    if (typeof element !== 'object') {
        if (typeof element !== 'number' && !element)
            return '';
        return svgConverter(element);
    }
    const el = element;
    if (el.type && el.attrs && el.__internal === 'svg-table-element-as-obj') {
        const children = typeof el.children === 'string'
            ? el.children
            : el.children
                ? el.children
                    .map(c => (typeof c === 'boolean' && !c ? null : svgConverter(c)))
                    .filter(v => v)
                    .join('\n')
                : '';
        const kebabCaseProps = convertToKebabCaseProps(el.attrs);
        const attrs = Object.entries(kebabCaseProps)
            .map(entry => {
            const [key, val] = entry;
            return `${key}="${val}"`;
        })
            .filter(v => v)
            .join(' ');
        return `<${el.type} ${attrs}>${children}</${el.type}>`;
    }
    if (el.__internal === 'svg-table-rendered-text') {
        const children = typeof el.children === 'string' ? el.children : el.children ? el.children.filter(v => v).join('\n') : '';
        return children;
    }
    return element.outerHTML;
};
//# sourceMappingURL=svgConverter.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-vanilla/dist/SVGTable.js


const SVGTable = (tableProps) => {
    const element = SVGTableBase(tableProps);
    return svgConverter(element);
};
//# sourceMappingURL=SVGTable.js.map
;// CONCATENATED MODULE: ../node_modules/@shjeon0730/svg-table-vanilla/dist/index.js




/* harmony default export */ const dist = (SVGTable);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./index.ts
// @ts-ignore

// @ts-ignore


var __webpack_exports___private_ = __webpack_exports__.Ee;
var __webpack_exports__convertToKebabCaseProps = __webpack_exports__.nI;
var __webpack_exports__createRenderedString = __webpack_exports__.V6;
var __webpack_exports__createVanillaElement = __webpack_exports__.CK;
var __webpack_exports__default = __webpack_exports__.ZP;
var __webpack_exports__kebabize = __webpack_exports__.iS;
var __webpack_exports__simpleValue = __webpack_exports__.s1;
export { __webpack_exports___private_ as __private__, __webpack_exports__convertToKebabCaseProps as convertToKebabCaseProps, __webpack_exports__createRenderedString as createRenderedString, __webpack_exports__createVanillaElement as createVanillaElement, __webpack_exports__default as default, __webpack_exports__kebabize as kebabize, __webpack_exports__simpleValue as simpleValue };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ZnLXRhYmxlLXZhbmlsbGEuMy4xLjMuZXNtLm1pbi5qcyIsIm1hcHBpbmdzIjoiU0FBQTtTQUNBOzs7OztVQ0RBO1VBQ0E7VUFDQTtVQUNBO1VBQ0EseUNBQXlDLHdDQUF3QztVQUNqRjtVQUNBO1VBQ0E7Ozs7O1VDUEE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0EsQ0FBQztBQUNNO0FBQ1AsbUJBQW1CLGtDQUFrQyxJQUFJLHNCQUFzQjtBQUMvRSxDQUFDO0FBQ0Q7O0FDVmdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSwyQkFBMkI7QUFDeEc7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJLElBQUksSUFBSTtBQUNsQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQixTQUFTLEVBQUUsTUFBTSxHQUFHLFNBQVMsSUFBSSxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEMwRDtBQUNaO0FBQ3ZDO0FBQ1Asb0JBQW9CLFlBQVk7QUFDaEMsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7O0FDTnNDO0FBQ2Q7QUFDaUM7QUFDakM7QUFDeEIsMkNBQWUsUUFBUSxFQUFDO0FBQ3hCOztBQ0xBO0FBQzhDO0FBQzlDO0FBQ3dEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac2hqZW9uMDczMC9zdmctdGFibGUtY29yZS9kaXN0L2NvbnN0cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BzaGplb24wNzMwL3N2Zy10YWJsZS1jb3JlL2Rpc3QvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac2hqZW9uMDczMC9zdmctdGFibGUtY29yZS9kaXN0L2VsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac2hqZW9uMDczMC9zdmctdGFibGUtY29yZS9kaXN0L1BhdGhPbkFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac2hqZW9uMDczMC9zdmctdGFibGUtY29yZS9kaXN0L0ZpbGxlZEFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac2hqZW9uMDczMC9zdmctdGFibGUtY29yZS9kaXN0L0NlbnRlcmVkQ2VsbENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac2hqZW9uMDczMC9zdmctdGFibGUtY29yZS9kaXN0L0FDZWxsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNoamVvbjA3MzAvc3ZnLXRhYmxlLWNvcmUvZGlzdC9jYWxjdWxhdGVSb3dzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNoamVvbjA3MzAvc3ZnLXRhYmxlLWNvcmUvZGlzdC9TVkdUYWJsZUJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac2hqZW9uMDczMC9zdmctdGFibGUtY29yZS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNoamVvbjA3MzAvc3ZnLXRhYmxlLXZhbmlsbGEvZGlzdC91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BzaGplb24wNzMwL3N2Zy10YWJsZS12YW5pbGxhL2Rpc3Qvc3ZnQ29udmVydGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNoamVvbjA3MzAvc3ZnLXRhYmxlLXZhbmlsbGEvZGlzdC9TVkdUYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BzaGplb24wNzMwL3N2Zy10YWJsZS12YW5pbGxhL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhlIHJlcXVpcmUgc2NvcGVcbnZhciBfX3dlYnBhY2tfcmVxdWlyZV9fID0ge307XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCJleHBvcnQgY29uc3QgSU5URVJOQUxfQ1NTX1ZBUlMgPSBPYmplY3QuZnJlZXplKHtcbiAgICBib3JkZXJMaW5lQ29sb3I6ICctLWxpbmUtZGVmYXVsdC1zdHJva2UnLFxuICAgIHRleHRDb2xvcjogJy0tdGV4dC1kZWZhdWx0LWNvbG9yJyxcbn0pO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ09MT1JTID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgYm9yZGVyOiAnIzAwMCcsXG59KTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX1dJVEhfQ1NTVkFSUyA9IE9iamVjdC5mcmVlemUoe1xuICAgIGJvcmRlcjogYHZhcigke0lOVEVSTkFMX0NTU19WQVJTLmJvcmRlckxpbmVDb2xvcn0sICR7REVGQVVMVF9DT0xPUlMuYm9yZGVyfSlgLFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdHMuanMubWFwIiwiaW1wb3J0IHsgREVGQVVMVF9XSVRIX0NTU1ZBUlMgfSBmcm9tICcuL2NvbnN0cyc7XG5jb25zdCBnZXRWYWxGcm9tQXJyID0gKGFyciwgcG9zKSA9PiB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJbM107XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyclsxXTtcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyclsyXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXJyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBzd2l0Y2ggKHBvcykge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyclsxXTtcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyWzFdO1xuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufTtcbmV4cG9ydCBjb25zdCBnZXRXaWQgPSAod2lkdGhzLCBwb3MpID0+IHtcbiAgICBpZiAod2lkdGhzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmICh0eXBlb2Ygd2lkdGhzID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIHdpZHRocztcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh3aWR0aHMpKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGdldFZhbEZyb21BcnIod2lkdGhzLCBwb3MpO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIHdpZHRocyB0eXBlOiAnLCB3aWR0aHMsICdmb3InLCBwb3MsICcgc2hvdWxkIGJlIG51bWJlciBvciBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSBvciBbbnVtYmVyLCBudW1iZXJdJyk7XG4gICAgcmV0dXJuIDA7XG59O1xuZXhwb3J0IGNvbnN0IGdldFdpZFZpc2libGUgPSAod2lkdGhzKSA9PiB7XG4gICAgaWYgKHdpZHRocyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiB3aWR0aHMgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gd2lkdGhzID4gMDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh3aWR0aHMpKSB7XG4gICAgICAgIHJldHVybiB3aWR0aHMuc29tZSh3ID0+IHcgPiAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydCBjb25zdCBnZXRTdHJva2VDb2xvciA9IChjb2xvcnMsIHBvcykgPT4ge1xuICAgIGlmICghY29sb3JzKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgY29sb3JzID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGNvbG9ycztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xvcnMpKSB7XG4gICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGdldFZhbEZyb21BcnIoY29sb3JzLCBwb3MpO1xuICAgICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKGNvbG9ycyAmJiBBcnJheS5pc0FycmF5KGNvbG9ycykgPyBjb2xvcnNbMF0gOiBjb2xvcnMpID8/IERFRkFVTFRfV0lUSF9DU1NWQVJTLmJvcmRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGNvbG9ycyB0eXBlOiAnLCBjb2xvcnMsICcgc2hvdWxkIGJlIHN0cmluZyBvciBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nXSBvciBbc3RyaW5nLCBzdHJpbmddJyk7XG4gICAgcmV0dXJuIERFRkFVTFRfV0lUSF9DU1NWQVJTLmJvcmRlcjtcbn07XG5leHBvcnQgY29uc3QgaXNWYWxpZGF0ZUFycmF5VHlwZSA9IChhcnIsIHR5cGUpID0+IHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpICYmIGFyci5ldmVyeShpdGVtID0+IHR5cGVvZiBpdGVtID09PSB0eXBlKTtcbn07XG5leHBvcnQgY29uc3QgaXNWYWxpZGF0ZTJEQXJyYXlUeXBlID0gKGFyciwgdHlwZSkgPT4ge1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShhcnIpICYmXG4gICAgICAgIGFyci5ldmVyeShpdGVtID0+IHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGl0ZW0pICYmIGlzVmFsaWRhdGVBcnJheVR5cGUoaXRlbSwgdHlwZSk7XG4gICAgICAgIH0pKTtcbn07XG5leHBvcnQgY29uc3QgZ2V0RGFzaEFycmF5ID0gKGRhc2hBcnJheXMsIHBvcykgPT4ge1xuICAgIGlmIChkYXNoQXJyYXlzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKGlzVmFsaWRhdGVBcnJheVR5cGUoZGFzaEFycmF5cywgJ251bWJlcicpKSB7XG4gICAgICAgIHJldHVybiBkYXNoQXJyYXlzLm1hcChhID0+IGEudG9TdHJpbmcoKSkuam9pbignICcpO1xuICAgIH1cbiAgICBpZiAoaXNWYWxpZGF0ZTJEQXJyYXlUeXBlKGRhc2hBcnJheXMsICdudW1iZXInKSkge1xuICAgICAgICBjb25zdCBhcnIgPSBkYXNoQXJyYXlzO1xuICAgICAgICBjb25zdCB2YWwgPSBnZXRWYWxGcm9tQXJyKGFyciwgcG9zKTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHZhbC5tYXAoYSA9PiBhLnRvU3RyaW5nKCkpLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcignSW52YWxpZCBkYXNoQXJyYXlzIHR5cGU6ICcsIGRhc2hBcnJheXMsICcgc2hvdWxkIGJlIG51bWJlcltdIG9yIFtudW1iZXJbXSwgbnVtYmVyW10sIG51bWJlcltdLCBudW1iZXJbXV0gb3IgW251bWJlcltdLCBudW1iZXJbXV0nKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmNvbnN0IHZhbGlkYXRlZEJvcmRlclNoYXBlID0gKGJvcmRlclNoYXBlLCBkYXNoQXJyYXlzKSA9PiB7XG4gICAgaWYgKCFkYXNoQXJyYXlzICYmICFib3JkZXJTaGFwZSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAoIWRhc2hBcnJheXMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdib3JkZXIgc2hhcGUgZG9lcyBub3QgaGF2ZSBhbnkgZWZmZWN0IHdpdGhvdXQgZGFzaCBhcnJheXMuIGF1dG9tYXRpY2FsbHkgaWdub3JpbmcgaXQuJyk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghYm9yZGVyU2hhcGUgfHwgYm9yZGVyU2hhcGUgPT09ICdidXR0Jykge1xuICAgICAgICBjb25zdCBkYXNoQXJycyA9IGRhc2hBcnJheXMuc3BsaXQoJyAnKTtcbiAgICAgICAgaWYgKGRhc2hBcnJzLnNvbWUoKHZhbCwgaWR4KSA9PiB2YWwgPT09ICcwJyAmJiBpZHggJSAyID09PSAwKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignXCJidXR0XCIgYm9yZGVyIHNoYXBlKG9yIHVuZGVmaW5lZCAtIGRlZmF1bHQpIHdpbGwgbm90IGJlIHNob3duIHdpdGggMCBzaXplLiBpbiBvZGQgb3JkZXIuIGkuZS4gc3Ryb2tlLWRhc2hhcnJheT1cIjAgMVwiIHdpbGwgbm90IGJlIHNob3duIHNpbmNlIHRoZSBmaXJzdCB2YWx1ZSBpcyAwLicsICdcXG5cXG55b3VyIGRhc2ggYXJyYXk6JywgZGFzaEFycmF5cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJvcmRlclNoYXBlO1xufTtcbmV4cG9ydCBjb25zdCBnZXRCb3JkZXJTaGFwZSA9IChib3JkZXJTaGFwZXMsIGRhc2hBcnJheXMsIHBvcykgPT4ge1xuICAgIGlmICghYm9yZGVyU2hhcGVzKVxuICAgICAgICByZXR1cm4gdmFsaWRhdGVkQm9yZGVyU2hhcGUoYm9yZGVyU2hhcGVzLCBnZXREYXNoQXJyYXkoZGFzaEFycmF5cywgcG9zKSk7XG4gICAgaWYgKHR5cGVvZiBib3JkZXJTaGFwZXMgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdmFsaWRhdGVkQm9yZGVyU2hhcGUoYm9yZGVyU2hhcGVzLCBnZXREYXNoQXJyYXkoZGFzaEFycmF5cywgcG9zKSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYm9yZGVyU2hhcGVzKSkge1xuICAgICAgICBjb25zdCB2YWwgPSBnZXRWYWxGcm9tQXJyKGJvcmRlclNoYXBlcywgcG9zKTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVkQm9yZGVyU2hhcGUodmFsLCBnZXREYXNoQXJyYXkoZGFzaEFycmF5cywgcG9zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5lcnJvcignSW52YWxpZCBib3JkZXJTaGFwZXMgdHlwZTogJywgYm9yZGVyU2hhcGVzLCAnIHNob3VsZCBiZSBzdHJpbmcgb3IgW3N0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZ10gb3IgW3N0cmluZywgc3RyaW5nXScpO1xuICAgIHJldHVybiAnYnV0dCc7XG59O1xuZXhwb3J0IGNvbnN0IGlzQm9yZGVyUmVjdCA9IChzdHlsZSkgPT4ge1xuICAgIGNvbnN0IHsgYm9yZGVyV2lkdGhzLCBib3JkZXJDb2xvcnMsIGJvcmRlclBhdHRlcm5zLCBiZ0NvbG9yLCByeCwgcnkgfSA9IHN0eWxlO1xuICAgIGlmICghYmdDb2xvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAoKCFyeCB8fCB0eXBlb2YgcnggPT09ICdudW1iZXInKSAmJlxuICAgICAgICAoIXJ5IHx8IHR5cGVvZiByeSA9PT0gJ251bWJlcicpICYmXG4gICAgICAgICghYm9yZGVyV2lkdGhzIHx8IHR5cGVvZiBib3JkZXJXaWR0aHMgPT09ICdudW1iZXInKSAmJlxuICAgICAgICAoIWJvcmRlckNvbG9ycyB8fCB0eXBlb2YgYm9yZGVyQ29sb3JzID09PSAnc3RyaW5nJykgJiZcbiAgICAgICAgKCFib3JkZXJQYXR0ZXJucyB8fCAoQXJyYXkuaXNBcnJheShib3JkZXJQYXR0ZXJucykgJiYgdHlwZW9mIGJvcmRlclBhdHRlcm5zWzBdID09PSAnbnVtYmVyJykpKTtcbn07XG5leHBvcnQgY29uc3QgZ2V0UmVjdFN0eWxlID0gKHN0eWxlKSA9PiB7XG4gICAgaWYgKCFpc0JvcmRlclJlY3Qoc3R5bGUpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB7IGJnQ29sb3IsIGJvcmRlcldpZHRocywgYm9yZGVyQ29sb3JzLCBib3JkZXJQYXR0ZXJucywgcngsIHJ5IH0gPSBzdHlsZTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi4oYmdDb2xvciA/IHsgZmlsbDogYmdDb2xvciB9IDoge30pLFxuICAgICAgICAuLi4ocnggfHwgcnkgPyB7IHJ4OiByeCA/PyAwLCByeTogcnkgPz8gMCB9IDoge30pLFxuICAgICAgICBzdHJva2U6IChib3JkZXJDb2xvcnMgPz8gREVGQVVMVF9XSVRIX0NTU1ZBUlMuYm9yZGVyKSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IGJvcmRlcldpZHRocyxcbiAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBnZXREYXNoQXJyYXkoYm9yZGVyUGF0dGVybnMsICdsZWZ0JyksXG4gICAgfTtcbn07XG5leHBvcnQgY29uc3Qgc2ltcGxlVmFsdWUgPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsLnRvRml4ZWQoMikpO1xufTtcbmV4cG9ydCBjb25zdCBjYW1lbFRvS2ViYWJDYXNlID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoL1tBLVpdL2csIGxldHRlciA9PiBgLSR7bGV0dGVyLnRvTG93ZXJDYXNlKCl9YCk7XG5leHBvcnQgY29uc3Qga2ViYWJUb0NhbWVsQ2FzZSA9IChzdHIpID0+IHN0clxuICAgIC5zcGxpdCgnLScpXG4gICAgLm1hcCgodiwgaSkgPT4gKGkgPT09IDAgPyB2IDogdlswXT8udG9VcHBlckNhc2UoKSArIHYuc3Vic3RyaW5nKDEpKSlcbiAgICAuam9pbignJyk7XG5leHBvcnQgY29uc3QgZ2V0RHVwbGljYXRlZFByb3BzID0gKGF0dHIpID0+IHtcbiAgICBPYmplY3Qua2V5cyhhdHRyKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGF0dHJbY2FtZWxUb0tlYmFiQ2FzZShrZXkpXSA9IGF0dHJba2V5XTtcbiAgICB9KTtcbiAgICBPYmplY3Qua2V5cyhhdHRyKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGF0dHJba2ViYWJUb0NhbWVsQ2FzZShrZXkpXSA9IGF0dHJba2V5XTtcbiAgICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJleHBvcnQgY29uc3QgZWxlbWVudCA9ICh0eXBlLCBhdHRycywgLi4uY2hpbGRyZW4pID0+IHtcbiAgICBjb25zdCB2YWxpZENoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+IGNoaWxkICE9PSB1bmRlZmluZWQgJiYgY2hpbGQgIT09IG51bGwpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRycykubGVuZ3RoID4gMCB8fCB2YWxpZENoaWxkcmVuLmxlbmd0aCA+IDBcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBfX2ludGVybmFsOiAnc3ZnLXRhYmxlLWVsZW1lbnQtYXMtb2JqJyxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBhdHRycyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiB2YWxpZENoaWxkcmVuLmxlbmd0aCA+IDAgJiYgQXJyYXkuaXNBcnJheSh2YWxpZENoaWxkcmVuWzBdKSA/IHZhbGlkQ2hpbGRyZW5bMF0gOiB2YWxpZENoaWxkcmVuLFxuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsZW1lbnQuanMubWFwIiwiaW1wb3J0IHsgZWxlbWVudCB9IGZyb20gJy4vZWxlbWVudCc7XG5pbXBvcnQgeyBnZXRCb3JkZXJTaGFwZSwgZ2V0U3Ryb2tlQ29sb3IsIGdldERhc2hBcnJheSwgZ2V0V2lkIH0gZnJvbSAnLi91dGlscyc7XG5jb25zdCBQYXRoID0gKHsgc3RhcnRQdCwgZW5kUHQsIHdpZHRoLCBib3JkZXJDb2xvcnMsIGJvcmRlclBhdHRlcm5zLCBib3JkZXJTaGFwZXMsIHBvcywgY2xhc3NOYW1lLCB9KSA9PiB7XG4gICAgaWYgKHdpZHRoID09PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gZWxlbWVudCgncGF0aCcsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgPyBgJHtwb3N9LXBhdGhgIDogdW5kZWZpbmVkLFxuICAgICAgICBkOiBgTSR7c3RhcnRQdH0gTCR7ZW5kUHR9YCxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHdpZHRoLFxuICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGJvcmRlckNvbG9ycywgcG9zKSxcbiAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBnZXREYXNoQXJyYXkoYm9yZGVyUGF0dGVybnMsIHBvcyksXG4gICAgICAgIHN0cm9rZUxpbmVjYXA6IGdldEJvcmRlclNoYXBlKGJvcmRlclNoYXBlcywgYm9yZGVyUGF0dGVybnMsIHBvcyksXG4gICAgfSk7XG59O1xuY29uc3QgZ2V0UHQgPSAoeCwgeSkgPT4gYCR7eH0sJHt5fWA7XG5leHBvcnQgY29uc3QgUGF0aE9uQXJlYSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgYm9yZGVyV2lkdGhzLCBib3JkZXJDb2xvcnMsIGJvcmRlclBhdHRlcm5zLCBib3JkZXJTaGFwZXMsIGNsYXNzTmFtZSwgcnggPSAwLCByeSA9IDAsIH0gPSBwcm9wcztcbiAgICBjb25zdCBQYXRoUHJvcHMgPSB7XG4gICAgICAgIGJvcmRlckNvbG9ycyxcbiAgICAgICAgYm9yZGVyUGF0dGVybnMsXG4gICAgICAgIGJvcmRlclNoYXBlcyxcbiAgICB9O1xuICAgIGNvbnN0IGNvcm5lckV4aXN0ID0gcnggJiYgcnk7XG4gICAgY29uc3QgbGVmdFRvcCA9IGdldFB0KDAsIDApO1xuICAgIGNvbnN0IGxlZnRCb3R0b20gPSBnZXRQdCgwLCBoZWlnaHQgLSAwKTtcbiAgICBjb25zdCByaWdodFRvcCA9IGdldFB0KHdpZHRoIC0gMCwgMCk7XG4gICAgY29uc3QgcmlnaHRCb3R0b20gPSBnZXRQdCh3aWR0aCAtIDAsIGhlaWdodCAtIDApO1xuICAgIGlmIChjb3JuZXJFeGlzdCkge1xuICAgICAgICBjb25zdCB3aWR0aCA9IChib3JkZXJXaWR0aHMgJiYgQXJyYXkuaXNBcnJheShib3JkZXJXaWR0aHMpID8gYm9yZGVyV2lkdGhzWzBdIDogYm9yZGVyV2lkdGhzKSA/PyAwO1xuICAgICAgICBpZiAoIXdpZHRoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGxlZnRMaW5lVG9wID0gZ2V0UHQoMCwgcnkpO1xuICAgICAgICBjb25zdCBsZWZ0TGluZUJvdHRvbSA9IGdldFB0KDAsIGhlaWdodCAtIHJ5KTtcbiAgICAgICAgY29uc3QgdG9wTGluZUxlZnQgPSBnZXRQdChyeCwgMCk7XG4gICAgICAgIGNvbnN0IHRvcExpbmVSaWdodCA9IGdldFB0KHdpZHRoIC0gcngsIDApO1xuICAgICAgICBjb25zdCByaWdodExpbmVUb3AgPSBnZXRQdCh3aWR0aCwgcnkpO1xuICAgICAgICBjb25zdCByaWdodExpbmVCb3R0b20gPSBnZXRQdCh3aWR0aCwgaGVpZ2h0IC0gcnkpO1xuICAgICAgICBjb25zdCBib3R0b21MaW5lTGVmdCA9IGdldFB0KHJ4LCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBib3R0b21MaW5lUmlnaHQgPSBnZXRQdCh3aWR0aCAtIHJ4LCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4gZWxlbWVudCgnZycsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYHBhdGhzLW9uLWFyZWEgJHtjbGFzc05hbWV9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSwgZWxlbWVudCgncGF0aCcsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYCR7Y2xhc3NOYW1lfS1jb3JuZXItcGF0aGAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkOiBgTSR7bGVmdExpbmVUb3B9IFEke2xlZnRUb3B9LCR7dG9wTGluZUxlZnR9IEwke3RvcExpbmVSaWdodH0gUSR7cmlnaHRUb3B9LCR7cmlnaHRMaW5lVG9wfSBMJHtyaWdodExpbmVCb3R0b219IFEke3JpZ2h0Qm90dG9tfSwke2JvdHRvbUxpbmVSaWdodH0gTCR7Ym90dG9tTGluZUxlZnR9IFEke2xlZnRCb3R0b219LCR7bGVmdExpbmVCb3R0b219IEwke2xlZnRMaW5lVG9wfWAsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICBzdHJva2U6IGdldFN0cm9rZUNvbG9yKGJvcmRlckNvbG9ycyksXG4gICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IGdldERhc2hBcnJheShib3JkZXJQYXR0ZXJucyksXG4gICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBnZXRCb3JkZXJTaGFwZShib3JkZXJTaGFwZXMsIGJvcmRlclBhdHRlcm5zKSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbGVmdFdpZCA9IGdldFdpZChib3JkZXJXaWR0aHMsICdsZWZ0Jyk7XG4gICAgICAgIGNvbnN0IHJpZ2h0V2lkID0gZ2V0V2lkKGJvcmRlcldpZHRocywgJ3JpZ2h0Jyk7XG4gICAgICAgIGNvbnN0IHRvcFdpZCA9IGdldFdpZChib3JkZXJXaWR0aHMsICd0b3AnKTtcbiAgICAgICAgY29uc3QgYm90dG9tV2lkID0gZ2V0V2lkKGJvcmRlcldpZHRocywgJ2JvdHRvbScpO1xuICAgICAgICByZXR1cm4gZWxlbWVudCgnZycsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYHBhdGhzLW9uLWFyZWEgJHtjbGFzc05hbWV9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSwgISFsZWZ0V2lkICYmXG4gICAgICAgICAgICBQYXRoKHtcbiAgICAgICAgICAgICAgICBzdGFydFB0OiBsZWZ0VG9wLFxuICAgICAgICAgICAgICAgIGVuZFB0OiBsZWZ0Qm90dG9tLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBsZWZ0V2lkLFxuICAgICAgICAgICAgICAgIC4uLlBhdGhQcm9wcyxcbiAgICAgICAgICAgICAgICBwb3M6ICdsZWZ0JyxcbiAgICAgICAgICAgIH0pLCAhIXJpZ2h0V2lkICYmXG4gICAgICAgICAgICBQYXRoKHtcbiAgICAgICAgICAgICAgICBzdGFydFB0OiByaWdodFRvcCxcbiAgICAgICAgICAgICAgICBlbmRQdDogcmlnaHRCb3R0b20sXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJpZ2h0V2lkLFxuICAgICAgICAgICAgICAgIC4uLlBhdGhQcm9wcyxcbiAgICAgICAgICAgICAgICBwb3M6ICdyaWdodCcsXG4gICAgICAgICAgICB9KSwgISF0b3BXaWQgJiZcbiAgICAgICAgICAgIFBhdGgoe1xuICAgICAgICAgICAgICAgIHN0YXJ0UHQ6IGxlZnRUb3AsXG4gICAgICAgICAgICAgICAgZW5kUHQ6IHJpZ2h0VG9wLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0b3BXaWQsXG4gICAgICAgICAgICAgICAgLi4uUGF0aFByb3BzLFxuICAgICAgICAgICAgICAgIHBvczogJ3RvcCcsXG4gICAgICAgICAgICB9KSwgISFib3R0b21XaWQgJiZcbiAgICAgICAgICAgIFBhdGgoe1xuICAgICAgICAgICAgICAgIHN0YXJ0UHQ6IGxlZnRCb3R0b20sXG4gICAgICAgICAgICAgICAgZW5kUHQ6IHJpZ2h0Qm90dG9tLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBib3R0b21XaWQsXG4gICAgICAgICAgICAgICAgLi4uUGF0aFByb3BzLFxuICAgICAgICAgICAgICAgIHBvczogJ2JvdHRvbScsXG4gICAgICAgICAgICB9KSk7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhdGhPbkFyZWEuanMubWFwIiwiaW1wb3J0IHsgZ2V0UmVjdFN0eWxlLCBnZXRXaWRWaXNpYmxlLCBpc0JvcmRlclJlY3QgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IFBhdGhPbkFyZWEgfSBmcm9tICcuL1BhdGhPbkFyZWEnO1xuaW1wb3J0IHsgZWxlbWVudCB9IGZyb20gJy4vZWxlbWVudCc7XG5jb25zdCBGaWxsZWRBcmVhID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBiZ0NvbG9yLCB3aWR0aCwgaGVpZ2h0LCBib3JkZXJXaWR0aHMsIGJvcmRlckNvbG9ycywgYm9yZGVyUGF0dGVybnMsIGJvcmRlclNoYXBlcywgY2xhc3NOYW1lLCByeCwgcnkgfSA9IHByb3BzO1xuICAgIGNvbnN0IGlzQmdDb2xvclZpc2libGUgPSBiZ0NvbG9yICYmIGJnQ29sb3IgIT09ICd0cmFuc3BhcmVudCc7XG4gICAgY29uc3QgaXNCb3JkZXJPblJlY3QgPSBpc0JnQ29sb3JWaXNpYmxlICYmIGlzQm9yZGVyUmVjdChwcm9wcyk7XG4gICAgY29uc3QgcmVjdFN0eWxlUHJvcHMgPSBpc0JvcmRlck9uUmVjdCA/IGdldFJlY3RTdHlsZShwcm9wcykgOiB7IGZpbGw6IGJnQ29sb3IgfTtcbiAgICBjb25zdCBpc0ZpbGxlZEFyZWFWaXNpYmxlID0gaXNCZ0NvbG9yVmlzaWJsZSB8fCBnZXRXaWRWaXNpYmxlKGJvcmRlcldpZHRocyk7XG4gICAgcmV0dXJuIGlzRmlsbGVkQXJlYVZpc2libGVcbiAgICAgICAgPyBlbGVtZW50KCdnJywge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgPyBgZmlsbGVkLWFyZWEgJHtjbGFzc05hbWUgPz8gJyd9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSwgaXNCZ0NvbG9yVmlzaWJsZSAmJlxuICAgICAgICAgICAgZWxlbWVudCgncmVjdCcsIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgLi4ucmVjdFN0eWxlUHJvcHMsXG4gICAgICAgICAgICB9KSwgIWlzQm9yZGVyT25SZWN0ICYmXG4gICAgICAgICAgICBQYXRoT25BcmVhKHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSA/ICdwYXRocy1vbi1hcmVhLWZvci1maWxsZWQtYXJlYScgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoczogYm9yZGVyV2lkdGhzLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yczogYm9yZGVyQ29sb3JzLFxuICAgICAgICAgICAgICAgIGJvcmRlclBhdHRlcm5zOiBib3JkZXJQYXR0ZXJucyxcbiAgICAgICAgICAgICAgICBib3JkZXJTaGFwZXM6IGJvcmRlclNoYXBlcyxcbiAgICAgICAgICAgICAgICByeCxcbiAgICAgICAgICAgICAgICByeSxcbiAgICAgICAgICAgIH0pKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbn07XG5leHBvcnQgZGVmYXVsdCBGaWxsZWRBcmVhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsbGVkQXJlYS5qcy5tYXAiLCJpbXBvcnQgeyBnZXREdXBsaWNhdGVkUHJvcHMsIHNpbXBsZVZhbHVlIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBlbGVtZW50IH0gZnJvbSAnLi9lbGVtZW50JztcbmV4cG9ydCBjb25zdCBDZW50ZXJlZENlbGxDb250ZW50ID0gKHsgY2VsbE9wdCwgc3R5bGVUb1VzZSwgY2hpbGRyZW4sIH0pID0+IHtcbiAgICBsZXQgeyB3aWR0aCwgaGVpZ2h0LCBjbGFzc05hbWUgfSA9IGNlbGxPcHQ7XG4gICAgbGV0IHsgcm90YXRlQ2VudGVyUHJvcHMsIGN4ID0gMCwgY3kgPSAwIH0gPSBzdHlsZVRvVXNlO1xuICAgIGNvbnN0IHByb3BzVG9QYXNzRm9yR3JvdXAgPSAoc3RhcnRYLCBzdGFydFkpID0+ICh7XG4gICAgICAgIHg6IHNpbXBsZVZhbHVlKHN0YXJ0WCksXG4gICAgICAgIHk6IHNpbXBsZVZhbHVlKHN0YXJ0WSksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgfSk7XG4gICAgY29uc3Qgcm90YXRpb25Hcm91cFByb3BzID0ge1xuICAgICAgICAuLi4odHlwZW9mIHJvdGF0ZUNlbnRlclByb3BzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHJvdGF0ZUNlbnRlclByb3BzKHByb3BzVG9QYXNzRm9yR3JvdXAod2lkdGggLyAyICsgY3gsIGhlaWdodCAvIDIgKyBjeSkpXG4gICAgICAgICAgICA6IHJvdGF0ZUNlbnRlclByb3BzKSxcbiAgICB9O1xuICAgIGdldER1cGxpY2F0ZWRQcm9wcyhyb3RhdGlvbkdyb3VwUHJvcHMpO1xuICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIDEpO1xuICAgIGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgMSk7XG4gICAgcmV0dXJuIGVsZW1lbnQoJ3N2ZycsIHtcbiAgICAgICAgdmlld0JveDogYCR7LXdpZHRoIC8gMn0gJHstaGVpZ2h0IC8gMn0gJHt3aWR0aH0gJHtoZWlnaHR9YCxcbiAgICAgICAgc3R5bGU6IHsgb3ZlcmZsb3c6ICd2aXNpYmxlJyB9LFxuICAgIH0sIGVsZW1lbnQoJ2cnLCB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYCR7Y2xhc3NOYW1lfS1jb250ZW50YCA6IHVuZGVmaW5lZCxcbiAgICB9LCBlbGVtZW50KCdnJywgcm90YXRpb25Hcm91cFByb3BzLCBjaGlsZHJlbikpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DZW50ZXJlZENlbGxDb250ZW50LmpzLm1hcCIsImltcG9ydCB7IGdldER1cGxpY2F0ZWRQcm9wcywgZ2V0V2lkLCBzaW1wbGVWYWx1ZSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IEZpbGxlZEFyZWEgZnJvbSAnLi9GaWxsZWRBcmVhJztcbmltcG9ydCB7IENlbnRlcmVkQ2VsbENvbnRlbnQgfSBmcm9tICcuL0NlbnRlcmVkQ2VsbENvbnRlbnQnO1xuaW1wb3J0IHsgZWxlbWVudCB9IGZyb20gJy4vZWxlbWVudCc7XG5pbXBvcnQgeyBTVkdUYWJsZUJhc2UgfSBmcm9tICcuL1NWR1RhYmxlQmFzZSc7XG5jb25zdCBtb3ZlVG9MZWZ0VG9wID0gKHdpZHRoLCBoZWlnaHQsIGNvbnRlbnQpID0+IHtcbiAgICByZXR1cm4gZWxlbWVudCgnZycsIHtcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7LXdpZHRoIC8gMn0sICR7LWhlaWdodCAvIDJ9KWAsXG4gICAgfSwgY29udGVudCk7XG59O1xuY29uc3QgY29udmVydFRvVGFibGVJZk5lZWRlZCA9IChjb250ZW50VG91c2UsIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmdzLCBjZWxsT3B0KSA9PiB7XG4gICAgaWYgKGNvbnRlbnRUb3VzZS50YWJsZSkge1xuICAgICAgICBjb25zdCBwYWRMZWZ0ID0gZ2V0V2lkKHBhZGRpbmdzLCAnbGVmdCcpO1xuICAgICAgICBjb25zdCBwYWRUb3AgPSBnZXRXaWQocGFkZGluZ3MsICd0b3AnKTtcbiAgICAgICAgY29uc3QgcGFkUmlnaHQgPSBnZXRXaWQocGFkZGluZ3MsICdyaWdodCcpO1xuICAgICAgICBjb25zdCBwYWRCb3R0b20gPSBnZXRXaWQocGFkZGluZ3MsICdib3R0b20nKTtcbiAgICAgICAgY29uc3QgdGFibGVXaWQgPSBzaW1wbGVWYWx1ZSh3aWR0aCAtIHBhZFJpZ2h0IC0gcGFkTGVmdCk7XG4gICAgICAgIGNvbnN0IGFkanVzdFByb3BzID0gY2VsbE9wdC5faGVpZ2h0QWRqdXN0XG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNpbXBsZVZhbHVlKE1hdGgubWF4KGhlaWdodCAtIHBhZFRvcCAtIHBhZEJvdHRvbSwgMSkpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgaWYgKGNlbGxPcHQuX3N0YW5kYWxvbmUpXG4gICAgICAgICAgICBhZGp1c3RQcm9wcy5zdGFuZGFsb25lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFNWR1RhYmxlQmFzZSh7XG4gICAgICAgICAgICB3aWR0aDogc2ltcGxlVmFsdWUodGFibGVXaWQpLFxuICAgICAgICAgICAgLi4uYWRqdXN0UHJvcHMsXG4gICAgICAgICAgICAuLi5jb250ZW50VG91c2UudGFibGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29udGVudFRvdXNlO1xufTtcbmNvbnN0IHJlbmRlclRleHRPbmx5ID0gKGNvbnRlbnRUb1JlbmRlciwgc3RhcnRYLCBzdGFydFksIHRleHRBbmNob3IsIHN0eWxlVG9BcHBseSA9IHt9KSA9PiB7XG4gICAgY29uc3QgbGluZXMgPSBjb250ZW50VG9SZW5kZXIuc3BsaXQoJ1xcbicpO1xuICAgIGxldCB0ZXh0VG9SZW5kZXIgPSBbY29udGVudFRvUmVuZGVyXTtcbiAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IHN0eWxlVG9BcHBseS5mb250U2l6ZSB8fCAxNjtcbiAgICAgICAgdGV4dFRvUmVuZGVyID0gbGluZXNcbiAgICAgICAgICAgIC5maWx0ZXIodiA9PiB2KVxuICAgICAgICAgICAgLm1hcCgobGluZSwgaW5kZXgpID0+IGVsZW1lbnQoJ3RzcGFuJywge1xuICAgICAgICAgICAgZm9udFNpemUsXG4gICAgICAgICAgICB4OiBzdGFydFgsXG4gICAgICAgICAgICBkeTogaW5kZXggPT09IDAgPyAwIDogZm9udFNpemUsXG4gICAgICAgIH0sIGxpbmUpKTtcbiAgICAgICAgc3RhcnRZID0gc3RhcnRZIC0gKChsaW5lcy5sZW5ndGggLSAxKSAqIHNpbXBsZVZhbHVlKGZvbnRTaXplKSkgLyAyO1xuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgeDogc2ltcGxlVmFsdWUoc3RhcnRYKSxcbiAgICAgICAgeTogc2ltcGxlVmFsdWUoc3RhcnRZKSxcbiAgICAgICAgdGV4dEFuY2hvcjogdGV4dEFuY2hvcixcbiAgICAgICAgZG9taW5hbnRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICAgIC4uLnN0eWxlVG9BcHBseSxcbiAgICB9O1xuICAgIGdldER1cGxpY2F0ZWRQcm9wcyhwcm9wcyk7XG4gICAgcmV0dXJuIGVsZW1lbnQoJ3RleHQnLCBwcm9wcywgLi4udGV4dFRvUmVuZGVyKTtcbn07XG5jb25zdCBzdHlsZVdpdGhGaWxsID0gKHN0eWxlLCBjb2xvcikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZpbGw6IGNvbG9yLFxuICAgICAgICAuLi5zdHlsZSxcbiAgICB9O1xufTtcbmNvbnN0IGdldEFyaWFQcm9wcyA9IChjZWxsT3B0KSA9PiB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAnYXJpYS1jb2xzcGFuJzogY2VsbE9wdC5jb2xTcGFuICYmIGNlbGxPcHQuY29sU3BhbiA+IDEgPyBjZWxsT3B0LmNvbFNwYW4gOiB1bmRlZmluZWQsXG4gICAgICAgICdhcmlhLXJvd3NwYW4nOiBjZWxsT3B0LnJvd1NwYW4gJiYgY2VsbE9wdC5yb3dTcGFuID4gMSA/IGNlbGxPcHQucm93U3BhbiA6IHVuZGVmaW5lZCxcbiAgICB9KSk7XG59O1xuY29uc3QgZ2V0Q29udGVudHMgPSAoY2VsbE9wdCwgc3R5bGVUb1VzZSkgPT4ge1xuICAgIGNvbnN0IHsgY29udGVudCwgd2lkdGgsIGhlaWdodCwgYmVmb3JlLCBhZnRlciB9ID0gY2VsbE9wdDtcbiAgICBsZXQgeyBwYWRkaW5ncywgdGV4dENvbG9yLCB0ZXh0U3R5bGUsIGN4ID0gMCwgY3kgPSAwIH0gPSBzdHlsZVRvVXNlO1xuICAgIHRleHRTdHlsZSA9IHN0eWxlV2l0aEZpbGwodGV4dFN0eWxlLCB0ZXh0Q29sb3IpO1xuICAgIGNvbnN0IHsgY29udGVudDogYmVmb3JlMiwgLi4uYmVmb3JlT3B0cyB9ID0gdHlwZW9mIGJlZm9yZSA9PT0gJ29iamVjdCcgJiYgYmVmb3JlLmNvbnRlbnRcbiAgICAgICAgPyBiZWZvcmVcbiAgICAgICAgOiB7IGNvbnRlbnQ6IGJlZm9yZSB9O1xuICAgIGNvbnN0IHsgY29udGVudDogYWZ0ZXIyLCAuLi5hZnRlck9wdHMgfSA9IHR5cGVvZiBhZnRlciA9PT0gJ29iamVjdCcgJiYgYWZ0ZXIuY29udGVudFxuICAgICAgICA/IGFmdGVyXG4gICAgICAgIDogeyBjb250ZW50OiBhZnRlciB9O1xuICAgIGNvbnN0IGJlZm9yZVRleHRTdHlsZSA9IHN0eWxlV2l0aEZpbGwoYmVmb3JlT3B0cy50ZXh0U3R5bGUsIHRleHRDb2xvcik7XG4gICAgY29uc3QgYWZ0ZXJUZXh0U3R5bGUgPSBzdHlsZVdpdGhGaWxsKGFmdGVyT3B0cy50ZXh0U3R5bGUsIHRleHRDb2xvcik7XG4gICAgY29uc3QgcHJvcHNUb1Bhc3MgPSAodGV4dFN0eWxlVG9Vc2UsIGFuY2hvckJhc2UsIHN0YXJ0WCwgc3RhcnRZKSA9PiAoe1xuICAgICAgICB4OiBzaW1wbGVWYWx1ZShzdGFydFgpLFxuICAgICAgICB5OiBzaW1wbGVWYWx1ZShzdGFydFkpLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB0ZXh0Q29sb3IsXG4gICAgICAgIHRleHRTdHlsZToge1xuICAgICAgICAgICAgdGV4dEFuY2hvcjogYW5jaG9yQmFzZSxcbiAgICAgICAgICAgIGRvbWluYW50QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgICAgICAgLi4udGV4dFN0eWxlVG9Vc2UsXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgZ2V0Q29udGVudCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGNvbnRlbnQocHJvcHNUb1Bhc3ModGV4dFN0eWxlLCAnbWlkZGxlJywgd2lkdGggLyAyICsgY3gsIGhlaWdodCAvIDIgKyBjeSkpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gY29udmVydFRvVGFibGVJZk5lZWRlZChjb250ZW50LCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5ncywgY2VsbE9wdCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjb250ZW50VG9Vc2UgPSBnZXRDb250ZW50KCk7XG4gICAgbGV0IGJlZm9yZVRvVXNlID0gdHlwZW9mIGJlZm9yZTIgPT09ICdmdW5jdGlvbicgPyBiZWZvcmUyKHByb3BzVG9QYXNzKGJlZm9yZVRleHRTdHlsZSwgJ3N0YXJ0JywgMCwgaGVpZ2h0IC8gMikpIDogYmVmb3JlMjtcbiAgICBsZXQgYWZ0ZXJUb1VzZSA9IHR5cGVvZiBhZnRlcjIgPT09ICdmdW5jdGlvbicgPyBhZnRlcjIocHJvcHNUb1Bhc3MoYWZ0ZXJUZXh0U3R5bGUsICdlbmQnLCB3aWR0aCwgaGVpZ2h0IC8gMikpIDogYWZ0ZXIyO1xuICAgIGNvbnN0IGJlZm9yZUNvbnRlbnQgPSBiZWZvcmVUb1VzZSAmJiB0eXBlb2YgYmVmb3JlVG9Vc2UgPT09ICdzdHJpbmcnXG4gICAgICAgID8gcmVuZGVyVGV4dE9ubHkoYmVmb3JlVG9Vc2UsIDAsIGhlaWdodCAvIDIsICdzdGFydCcsIGJlZm9yZVRleHRTdHlsZSlcbiAgICAgICAgOiBiZWZvcmVUb1VzZTtcbiAgICBjb25zdCBhZnRlckNvbnRlbnQgPSBhZnRlclRvVXNlICYmIHR5cGVvZiBhZnRlclRvVXNlID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHJlbmRlclRleHRPbmx5KGFmdGVyVG9Vc2UsIHdpZHRoLCBoZWlnaHQgLyAyLCAnZW5kJywgYWZ0ZXJUZXh0U3R5bGUpXG4gICAgICAgIDogYWZ0ZXJUb1VzZTtcbiAgICBjb25zdCBtYWluQ29udGVudCA9IHR5cGVvZiBjb250ZW50VG9Vc2UgPT09ICdzdHJpbmcnXG4gICAgICAgID8gcmVuZGVyVGV4dE9ubHkoY29udGVudFRvVXNlLCBjeCwgY3ksICdtaWRkbGUnLCB0ZXh0U3R5bGUpXG4gICAgICAgIDogbW92ZVRvTGVmdFRvcCh3aWR0aCwgaGVpZ2h0LCBjb250ZW50VG9Vc2UpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJlZm9yZUNvbnRlbnQsXG4gICAgICAgIGFmdGVyQ29udGVudCxcbiAgICAgICAgbWFpbkNvbnRlbnQsXG4gICAgfTtcbn07XG5jb25zdCBGaWxsZWRBcmVhSW5DZWxsID0gKHsgY2VsbE9wdCwgc3R5bGVUb1VzZSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgY2xhc3NOYW1lIH0gPSBjZWxsT3B0O1xuICAgIGxldCB7IGJnQ29sb3IsIGJvcmRlcldpZHRocywgYm9yZGVyQ29sb3JzLCBib3JkZXJQYXR0ZXJucywgYm9yZGVyU2hhcGVzLCByeCwgcnkgfSA9IHN0eWxlVG9Vc2U7XG4gICAgcmV0dXJuIEZpbGxlZEFyZWEoe1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSA/IGAke2NsYXNzTmFtZX0tZmlsbGVkLWJhY2tgIDogdW5kZWZpbmVkLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBib3JkZXJXaWR0aHM6IGJvcmRlcldpZHRocyxcbiAgICAgICAgYm9yZGVyQ29sb3JzOiBib3JkZXJDb2xvcnMsXG4gICAgICAgIGJvcmRlclBhdHRlcm5zOiBib3JkZXJQYXR0ZXJucyxcbiAgICAgICAgYm9yZGVyU2hhcGVzOiBib3JkZXJTaGFwZXMsXG4gICAgICAgIHJ4LFxuICAgICAgICByeSxcbiAgICAgICAgLi4uKGJnQ29sb3IgPyB7IGJnQ29sb3IgfSA6IHt9KSxcbiAgICB9KTtcbn07XG5leHBvcnQgY29uc3QgQUNlbGwgPSAoeyBjZWxsT3B0LCBkZWZhdWx0U3R5bGUsIH0pID0+IHtcbiAgICBpZiAoY2VsbE9wdC5faWdub3JlZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgc3R5bGUsIGNsYXNzTmFtZSB9ID0gY2VsbE9wdDtcbiAgICBjb25zdCBzdHlsZVRvVXNlID0ge1xuICAgICAgICAuLi5kZWZhdWx0U3R5bGUsXG4gICAgICAgIC4uLnN0eWxlLFxuICAgIH07XG4gICAgbGV0IHsgcGFkZGluZ3MsIHN2Z1N0eWxlLCBhbGxvd092ZXJmbG93IH0gPSBzdHlsZVRvVXNlO1xuICAgIGNvbnN0IHBhZExlZnQgPSBnZXRXaWQocGFkZGluZ3MsICdsZWZ0Jyk7XG4gICAgY29uc3QgcGFkVG9wID0gZ2V0V2lkKHBhZGRpbmdzLCAndG9wJyk7XG4gICAgY29uc3Qgc3ZnU3R5bGVUb1VzZSA9IHtcbiAgICAgICAgLi4uc3ZnU3R5bGUsXG4gICAgICAgIC4uLihhbGxvd092ZXJmbG93ID8geyBvdmVyZmxvdzogJ3Zpc2libGUnIH0gOiB7fSksXG4gICAgfTtcbiAgICBjb25zdCBhcmlhUHJvcHMgPSBnZXRBcmlhUHJvcHMoY2VsbE9wdCk7XG4gICAgY29uc3QgeyBiZWZvcmVDb250ZW50LCBhZnRlckNvbnRlbnQsIG1haW5Db250ZW50IH0gPSBnZXRDb250ZW50cyhjZWxsT3B0LCBzdHlsZVRvVXNlKTtcbiAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCAxKTtcbiAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIDEpO1xuICAgIHJldHVybiBlbGVtZW50KCdnJywge1xuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt4fSwgJHt5fSlgLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSA/IGAke2NsYXNzTmFtZX0td3JhcHBlcmAgOiB1bmRlZmluZWQsXG4gICAgfSwgRmlsbGVkQXJlYUluQ2VsbCh7IGNlbGxPcHQ6IGNlbGxPcHQsIHN0eWxlVG9Vc2U6IHN0eWxlVG9Vc2UgfSksIGVsZW1lbnQoJ3N2ZycsIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgc3R5bGU6IHN2Z1N0eWxlVG9Vc2UsXG4gICAgICAgIHZpZXdCb3g6IGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YCxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgPyBjbGFzc05hbWUgOiB1bmRlZmluZWQsXG4gICAgfSwgZWxlbWVudCgnZycsIHtcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7cGFkTGVmdH0sICR7cGFkVG9wfSlgLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSA/IGAke2NsYXNzTmFtZX0tcGFkZGluZ2AgOiB1bmRlZmluZWQsXG4gICAgICAgIHJvbGU6ICdjZWxsJyxcbiAgICAgICAgLi4uYXJpYVByb3BzLFxuICAgIH0sIGJlZm9yZUNvbnRlbnQsIENlbnRlcmVkQ2VsbENvbnRlbnQoe1xuICAgICAgICBjZWxsT3B0OiBjZWxsT3B0LFxuICAgICAgICBzdHlsZVRvVXNlOiBzdHlsZVRvVXNlLFxuICAgICAgICBjaGlsZHJlbjogbWFpbkNvbnRlbnQsXG4gICAgfSksIGFmdGVyQ29udGVudCkpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BQ2VsbC5qcy5tYXAiLCJpbXBvcnQgeyBzaW1wbGVWYWx1ZSB9IGZyb20gJy4vdXRpbHMnO1xubGV0IGRlYnVnT2JqID0ge307XG5jb25zdCBnZXRDZWxsV2lkdGggPSAoY2VsbFdpZHRocywgc3RhcnRDb2wsIGNvbFNwYW4sIGNvbEdhcCkgPT4ge1xuICAgIGlmIChjZWxsV2lkdGhzLmxlbmd0aCA8IHN0YXJ0Q29sICsgY29sU3BhbiAtIDEpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTm90IGVub3VnaCBjb2x1bW4gd2lkdGhzIHByb3ZpZGVkLiBjaGVjayBjb2xTcGFuIG9mIHRoZSBjZWxsIGRhdGEuIHN0YXJ0Q29sOiAnICsgc3RhcnRDb2wsICdkYXRhIGlzOicsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGVidWdPYmopKSk7XG4gICAgfVxuICAgIHJldHVybiBzaW1wbGVWYWx1ZShjZWxsV2lkdGhzLnNsaWNlKHN0YXJ0Q29sLCBzdGFydENvbCArIGNvbFNwYW4pLnJlZHVjZSgodG90YWwsIHdpZHRoKSA9PiB0b3RhbCArIHdpZHRoLCAwKSArXG4gICAgICAgIGNvbEdhcCAqIChjb2xTcGFuIC0gMSkpO1xufTtcbmNvbnN0IGdldENlbGxIZWlnaHQgPSAocm93SGVpZ2h0cywgc3RhcnRSb3csIHJvd1NwYW4sIHJvd0dhcCkgPT4ge1xuICAgIGlmIChyb3dIZWlnaHRzLmxlbmd0aCA8IHN0YXJ0Um93ICsgcm93U3BhbiAtIDEpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTm90IGVub3VnaCByb3cgaGVpZ2h0cyBwcm92aWRlZC4gY2hlY2sgcm93U3BhbiBvZiB0aGUgY2VsbCBkYXRhLiBzdGFydFJvdzogJyArIHN0YXJ0Um93LCAnZGF0YSBpczonLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRlYnVnT2JqKSkpO1xuICAgIH1cbiAgICByZXR1cm4gKHJvd0hlaWdodHMuc2xpY2Uoc3RhcnRSb3csIHN0YXJ0Um93ICsgcm93U3BhbikucmVkdWNlKCh0b3RhbCwgaGVpZ2h0KSA9PiB0b3RhbCArIGhlaWdodCwgMCkgK1xuICAgICAgICByb3dHYXAgKiAocm93U3BhbiAtIDEpKTtcbn07XG5jb25zdCBpbnNlcnRJZ25vcmVkQ2VsbCA9IChyb3csIGNvbEluZGV4LCBjZWxsKSA9PiB7XG4gICAgcm93LmNlbGxzID0gW1xuICAgICAgICAuLi4ocm93LmNlbGxzLnNsaWNlKDAsIGNvbEluZGV4KSA/PyBbXSksXG4gICAgICAgIC4uLkFycmF5KGNlbGwuY29sU3BhbiA/PyAxKVxuICAgICAgICAgICAgLmZpbGwobnVsbClcbiAgICAgICAgICAgIC5tYXAoKCkgPT4gKHtcbiAgICAgICAgICAgIF9pZ25vcmVkOiB0cnVlLFxuICAgICAgICAgICAgY29sU3BhbjogMSxcbiAgICAgICAgfSkpLFxuICAgICAgICAuLi4ocm93LmNlbGxzLnNsaWNlKGNvbEluZGV4KSA/PyBbXSksXG4gICAgXTtcbn07XG5leHBvcnQgY29uc3QgY2FsY3VsYXRlUm93cyA9IChjZWxsV2lkdGhzLCByb3dIZWlnaHRzLCByb3dzLCBzdHlsZSwgdGFibGVQcm9wcykgPT4ge1xuICAgIGxldCBjdXJyZW50WSA9IDA7XG4gICAgY29uc3QgZW1iZWRlZFRhYmxlSGVpZ2h0QWRqdXN0ID0gISF0YWJsZVByb3BzLmhlaWdodDtcbiAgICBjb25zdCBzdGFuZGFsb25lVGFibGUgPSAhIXRhYmxlUHJvcHMuc3RhbmRhbG9uZTtcbiAgICBjb25zdCBjYWxjUm93cyA9IHJvd3MubWFwKGFSb3cgPT4ge1xuICAgICAgICBjb25zdCByb3cgPSBBcnJheS5pc0FycmF5KGFSb3cpID8geyBjZWxsczogYVJvdyB9IDogYVJvdztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnJvdyxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiBjdXJyZW50WSxcbiAgICAgICAgICAgIGhlaWdodDogLTEsXG4gICAgICAgICAgICB3aWR0aDogLTEsXG4gICAgICAgICAgICBjZWxsczogW1xuICAgICAgICAgICAgICAgIC4uLnJvdy5jZWxscy5tYXAoYUNlbGwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gdHlwZW9mIGFDZWxsID09PSAnc3RyaW5nJyA/IHsgY29udGVudDogYUNlbGwgfSA6IGFDZWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2lnbm9yZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2hlaWdodEFkanVzdDogZW1iZWRlZFRhYmxlSGVpZ2h0QWRqdXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YW5kYWxvbmU6IHN0YW5kYWxvbmVUYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgZm9yIChsZXQgcmkgPSAwOyByaSA8IGNhbGNSb3dzLmxlbmd0aDsgcmkrKykge1xuICAgICAgICBjb25zdCByb3cgPSBjYWxjUm93c1tyaV07XG4gICAgICAgIGlmICghcm93KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBjdXJyZW50WCA9IDA7XG4gICAgICAgIGxldCBpZHggPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93LmNlbGxzKSB7XG4gICAgICAgICAgICBkZWJ1Z09iaiA9IHtcbiAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICBjZWxsOiBjZWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjZWxsLl9pZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkVG9Ta2lwID0gZ2V0Q2VsbFdpZHRoKGNlbGxXaWR0aHMsIGlkeCwgMSwgc3R5bGU/LmNvbEdhcHMgPz8gMCk7XG4gICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICAgICAgY3VycmVudFggKz0gd2lkVG9Ta2lwICsgKHN0eWxlPy5jb2xHYXBzID8/IDApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNMYXN0Q2VsbEJ1dE5vdExhc3RDb2x1bW4gPSByb3cuY2VsbHNbcm93LmNlbGxzLmxlbmd0aCAtIDFdID09PSBjZWxsICYmIGlkeCAhPT0gY2VsbFdpZHRocy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgY29uc3QgY29sU3BhbiA9IGlzTGFzdENlbGxCdXROb3RMYXN0Q29sdW1uID8gY2VsbFdpZHRocy5sZW5ndGggLSBpZHggOiAxO1xuICAgICAgICAgICAgY2VsbC5jb2xTcGFuID0gY29sU3BhbjtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxXaWR0aCA9IGdldENlbGxXaWR0aChjZWxsV2lkdGhzLCBpZHgsIGNlbGwuY29sU3Bhbiwgc3R5bGU/LmNvbEdhcHMgPz8gMCk7XG4gICAgICAgICAgICBpZiAoY2VsbC5yb3dTcGFuKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjZWxsLnJvd1NwYW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsY1Jvd3NbcmkgKyBpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0SWdub3JlZENlbGwoY2FsY1Jvd3NbcmkgKyBpXSwgaWR4LCBjZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3JvdyBpcyBub3QgZm91bmQgYXQgaW5kZXg6ICcgKyAoaWR4ICsgaSksICd5b3VyIGNlbGwgaXM6JywgY2VsbCwgJ3lvdXIgcm93cyBhcmUnLCBjYWxjUm93cywgJ2lkeCBpcycsIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsLndpZHRoID0gY2VsbFdpZHRoO1xuICAgICAgICAgICAgY2VsbC5oZWlnaHQgPSBnZXRDZWxsSGVpZ2h0KHJvd0hlaWdodHMsIHJpLCBjZWxsLnJvd1NwYW4gPz8gMSwgc3R5bGU/LnJvd0dhcHMgPz8gMCk7XG4gICAgICAgICAgICBjZWxsLnggPSBzaW1wbGVWYWx1ZShjdXJyZW50WCk7XG4gICAgICAgICAgICBjZWxsLnkgPSBzaW1wbGVWYWx1ZShjdXJyZW50WSk7XG4gICAgICAgICAgICBjdXJyZW50WCArPSBjZWxsV2lkdGggKyAoc3R5bGU/LmNvbEdhcHMgPz8gMCk7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50WSArPSAocm93SGVpZ2h0c1tyaV0gPz8gMCkgKyAoc3R5bGU/LnJvd0dhcHMgPz8gMCk7XG4gICAgICAgIHJvdy5oZWlnaHQgPSBjdXJyZW50WTtcbiAgICAgICAgcm93LndpZHRoID0gY3VycmVudFg7XG4gICAgfVxuICAgIHJldHVybiBjYWxjUm93cztcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxjdWxhdGVSb3dzLmpzLm1hcCIsImltcG9ydCB7IEFDZWxsIH0gZnJvbSAnLi9BQ2VsbCc7XG5pbXBvcnQgeyBjYWxjdWxhdGVSb3dzIH0gZnJvbSAnLi9jYWxjdWxhdGVSb3dzJztcbmltcG9ydCB7IGdldFdpZCwgc2ltcGxlVmFsdWUgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBGaWxsZWRBcmVhIGZyb20gJy4vRmlsbGVkQXJlYSc7XG5pbXBvcnQgeyBJTlRFUk5BTF9DU1NfVkFSUyB9IGZyb20gJy4vY29uc3RzJztcbmltcG9ydCB7IGVsZW1lbnQgfSBmcm9tICcuL2VsZW1lbnQnO1xuY29uc3QgZ2V0VG90YWxDZWxscyA9IChjZWxscykgPT4ge1xuICAgIHJldHVybiBjZWxscy5yZWR1Y2UoKHRvdGFsLCBjZWxsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNlbGxBc09iaiA9IGNlbGw7XG4gICAgICAgIGlmICh0eXBlb2YgY2VsbEFzT2JqID09PSAnb2JqZWN0JyAmJiBjZWxsQXNPYmouY29sU3Bhbikge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgY2VsbEFzT2JqLmNvbFNwYW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsICsgMTtcbiAgICB9LCAwKTtcbn07XG5jb25zdCBwYXJzZWRUYWJsZVN0eWxlID0gKHN0eWxlKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm93R2FwczogMCxcbiAgICAgICAgY29sR2FwczogMCxcbiAgICAgICAgYm9yZGVyV2lkdGhzOiB1bmRlZmluZWQsXG4gICAgICAgIGJvcmRlclBhdHRlcm5zOiB1bmRlZmluZWQsXG4gICAgICAgIGJvcmRlclNoYXBlczogdW5kZWZpbmVkLFxuICAgICAgICBib3JkZXJDb2xvcnM6IHN0eWxlPy5ib3JkZXJXaWR0aHMgPyBgdmFyKCR7SU5URVJOQUxfQ1NTX1ZBUlMuYm9yZGVyTGluZUNvbG9yfSwgIzAwMClgIDogdW5kZWZpbmVkLFxuICAgICAgICBzdmdTdHlsZTogeyBvdmVyZmxvdzogJ3Zpc2libGUnIH0sXG4gICAgICAgIC4uLnN0eWxlLFxuICAgICAgICBtYXJnaW5zOiBzdHlsZT8ubWFyZ2lucyA/PyAwLFxuICAgIH07XG59O1xuY29uc3QgcGFyc2VEZWZhdWx0Q2VsbFN0eWxlQmFzZSA9IChkZWZhdWx0Q2VsbFN0eWxlQmFzZSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFsbG93T3ZlcmZsb3c6IGZhbHNlLFxuICAgICAgICBib3JkZXJXaWR0aHM6IDEsXG4gICAgICAgIGJnQ29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgdGV4dFN0eWxlOiB1bmRlZmluZWQsXG4gICAgICAgIGJvcmRlckNvbG9yczogYHZhcigke0lOVEVSTkFMX0NTU19WQVJTLmJvcmRlckxpbmVDb2xvcn0sICMwMDApYCxcbiAgICAgICAgYm9yZGVyUGF0dGVybnM6IHVuZGVmaW5lZCxcbiAgICAgICAgYm9yZGVyU2hhcGVzOiB1bmRlZmluZWQsXG4gICAgICAgIHBhZGRpbmdzOiBbMSwgMSwgMSwgMV0sXG4gICAgICAgIHRleHRDb2xvcjogYHZhcigke0lOVEVSTkFMX0NTU19WQVJTLnRleHRDb2xvcn0sICMwMDApYCxcbiAgICAgICAgLi4uZGVmYXVsdENlbGxTdHlsZUJhc2UsXG4gICAgICAgIG9ubHlJbm5lckJvcmRlcnM6IGRlZmF1bHRDZWxsU3R5bGVCYXNlPy5yeCAmJiBkZWZhdWx0Q2VsbFN0eWxlQmFzZT8ucnlcbiAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgOiAoZGVmYXVsdENlbGxTdHlsZUJhc2U/Lm9ubHlJbm5lckJvcmRlcnMgPz8gZmFsc2UpLFxuICAgIH07XG59O1xuY29uc3QgYWRqdXN0Q29sdW1uV2lkdGhzID0gKGNvbHVtbldpZHRocywgdGFibGVXaWR0aFdpdGhvdXRHYXBzKSA9PiB7XG4gICAgY29uc3QgdG90YWxXaWR0aCA9IGNvbHVtbldpZHRocy5yZWR1Y2UoKHRvdGFsLCB3aWR0aCkgPT4gdG90YWwgKyB3aWR0aCwgMCk7XG4gICAgY29uc3QgcmF0aW8gPSB0YWJsZVdpZHRoV2l0aG91dEdhcHMgLyB0b3RhbFdpZHRoO1xuICAgIGlmIChyYXRpbyA+IDAuOTkgJiYgcmF0aW8gPD0gMS4wMSlcbiAgICAgICAgcmV0dXJuIGNvbHVtbldpZHRocztcbiAgICByZXR1cm4gY29sdW1uV2lkdGhzLm1hcCh3aWR0aCA9PiBNYXRoLm1heChzaW1wbGVWYWx1ZSh3aWR0aCAqIHJhdGlvKSwgMSkpO1xufTtcbmNvbnN0IGFkanVzdFJvd0hlaWdodHMgPSAocm93SGVpZ2h0cywgdGFibGVIZWlnaHRXaXRob3V0R2FwcykgPT4ge1xuICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gcm93SGVpZ2h0cy5yZWR1Y2UoKHRvdGFsLCB3aWR0aCkgPT4gdG90YWwgKyB3aWR0aCwgMCk7XG4gICAgY29uc3QgcmF0aW8gPSB0YWJsZUhlaWdodFdpdGhvdXRHYXBzIC8gdG90YWxIZWlnaHQ7XG4gICAgaWYgKHJhdGlvID4gMC45OSAmJiByYXRpbyA8PSAxLjAxKVxuICAgICAgICByZXR1cm4gcm93SGVpZ2h0cztcbiAgICByZXR1cm4gcm93SGVpZ2h0cy5tYXAod2lkdGggPT4gTWF0aC5tYXgoc2ltcGxlVmFsdWUod2lkdGggKiByYXRpbyksIDEpKTtcbn07XG5sZXQgbWFza0lkU3JjID0gMDtcbmV4cG9ydCBjb25zdCBTVkdUYWJsZUJhc2UgPSAodGFibGVQcm9wc1dpdGhTdGFuZGFsb25lKSA9PiB7XG4gICAgY29uc3QgeyBzdGFuZGFsb25lID0gZmFsc2UsIC4uLnRhYmxlUHJvcHMgfSA9IHRhYmxlUHJvcHNXaXRoU3RhbmRhbG9uZTtcbiAgICBsZXQgeyByb3dzLCB3aWR0aCA9IDUwMCwgaGVpZ2h0OiBoZWlnaHRGcm9tUHJvcHMsIGRlZmF1bHRDZWxsU3R5bGUsIGRlZmF1bHRSb3dTdHlsZSwgY29sdW1uV2lkdGhzLCByb3dIZWlnaHRzOiByb3dIZWlnaHRGcm9tUHJvcHMsIHN0eWxlLCBjbGFzc05hbWUsIGRlZnMsIHN2Z0F0dHJzLCB9ID0gdGFibGVQcm9wcztcbiAgICBjb25zdCBkZWZhdWx0U3R5bGVGb3JDZWxsID0gcGFyc2VEZWZhdWx0Q2VsbFN0eWxlQmFzZShkZWZhdWx0Q2VsbFN0eWxlKTtcbiAgICBjb25zdCBtYXhDb2x1bW5zID0gTWF0aC5tYXgocm93cy5yZWR1Y2UoKG1heCwgcm93KSA9PiBBcnJheS5pc0FycmF5KHJvdykgPyBNYXRoLm1heChtYXgsIHJvdy5sZW5ndGgpIDogTWF0aC5tYXgobWF4LCBnZXRUb3RhbENlbGxzKHJvdy5jZWxscykpLCAwKSwgMSk7XG4gICAgY29uc3QgdGFibGVTdHlsZSA9IHBhcnNlZFRhYmxlU3R5bGUoc3R5bGUpO1xuICAgIGNvbnN0IGlzUm91bmRlZENvcm5lciA9ICEhKHRhYmxlU3R5bGUucnggJiYgdGFibGVTdHlsZS5yeSk7XG4gICAgY29uc3QgYWxsQ29sR2FwcyA9IChtYXhDb2x1bW5zIC0gMSkgKiB0YWJsZVN0eWxlLmNvbEdhcHMgK1xuICAgICAgICBnZXRXaWQodGFibGVTdHlsZS5tYXJnaW5zLCAnbGVmdCcpICtcbiAgICAgICAgZ2V0V2lkKHRhYmxlU3R5bGUubWFyZ2lucywgJ3JpZ2h0Jyk7XG4gICAgY29uc3QgYWxsUm93R2FwcyA9IChyb3dzLmxlbmd0aCAtIDEpICogdGFibGVTdHlsZS5yb3dHYXBzICtcbiAgICAgICAgZ2V0V2lkKHRhYmxlU3R5bGUubWFyZ2lucywgJ3RvcCcpICtcbiAgICAgICAgZ2V0V2lkKHRhYmxlU3R5bGUubWFyZ2lucywgJ2JvdHRvbScpO1xuICAgIGNvbnN0IGRlZmF1bHRTdHlsZUZvclJvdyA9IHtcbiAgICAgICAgaGVpZ2h0OiAzMCxcbiAgICAgICAgLi4uZGVmYXVsdFJvd1N0eWxlLFxuICAgIH07XG4gICAgbGV0IGhlaWdodCA9IGhlaWdodEZyb21Qcm9wcyA/P1xuICAgICAgICByb3dzLnJlZHVjZSgoaCwgcm93KSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyb3cpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGggKyBkZWZhdWx0U3R5bGVGb3JSb3cuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGggKyAocm93LnN0eWxlPy5oZWlnaHQgPz8gZGVmYXVsdFN0eWxlRm9yUm93LmhlaWdodCk7XG4gICAgICAgIH0sIDApICsgYWxsUm93R2FwcztcbiAgICBoZWlnaHQgPSBNYXRoLm1heChzaW1wbGVWYWx1ZShoZWlnaHQpLCAxKTtcbiAgICB3aWR0aCA9IE1hdGgubWF4KHNpbXBsZVZhbHVlKHdpZHRoKSwgMSk7XG4gICAgY29uc3QgY2VsbFdpZHRocyA9IGNvbHVtbldpZHRoc1xuICAgICAgICA/IGFkanVzdENvbHVtbldpZHRocyhjb2x1bW5XaWR0aHMsIHdpZHRoIC0gYWxsQ29sR2FwcylcbiAgICAgICAgOiBBcnJheShtYXhDb2x1bW5zKS5maWxsKHNpbXBsZVZhbHVlKCh3aWR0aCAtIGFsbENvbEdhcHMpIC8gbWF4Q29sdW1ucykpO1xuICAgIGxldCByb3dIZWlnaHRzID0gcm93SGVpZ2h0RnJvbVByb3BzID8/XG4gICAgICAgIHJvd3MubWFwKHJvdyA9PiByb3cuc3R5bGU/LmhlaWdodCA/PyBkZWZhdWx0U3R5bGVGb3JSb3cuaGVpZ2h0KTtcbiAgICBpZiAoaGVpZ2h0RnJvbVByb3BzKSB7XG4gICAgICAgIHJvd0hlaWdodHMgPSBhZGp1c3RSb3dIZWlnaHRzKHJvd0hlaWdodHMsIGhlaWdodEZyb21Qcm9wcyAtIGFsbFJvd0dhcHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJvd0hlaWdodEZyb21Sb3dTdHlsZSA9IHJvd3NbaV0/LnN0eWxlPy5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAocm93SGVpZ2h0RnJvbVJvd1N0eWxlICYmIHR5cGVvZiByb3dIZWlnaHRzW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJvd0hlaWdodHNbaV0gPSByb3dIZWlnaHRGcm9tUm93U3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2FsY3VsYXRlZFJvd3MgPSBjYWxjdWxhdGVSb3dzKGNlbGxXaWR0aHMsIHJvd0hlaWdodHMsIHJvd3MsIHRhYmxlU3R5bGUsIHRhYmxlUHJvcHMpO1xuICAgIGNvbnN0IHJvd3NDb250ZW50ID0gY2FsY3VsYXRlZFJvd3MubWFwKChyb3csIHJvd0luZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHJvd0NvbnRlbnQgPSBbXTtcbiAgICAgICAgaWYgKHJvdy5zdHlsZT8uYmdDb2xvcikge1xuICAgICAgICAgICAgcm93Q29udGVudC5wdXNoKGVsZW1lbnQoJ2cnLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7cm93Lnh9LCAke3Jvdy55fSlgLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYCR7Y2xhc3NOYW1lfS1yb3ctJHtyb3dJbmRleH0td3JhcHBlcmAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9LCBGaWxsZWRBcmVhKHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSA/IGAke2NsYXNzTmFtZX0tZmlsbGVkLWFyZWEtYmVoaW5kLXRhYmxlYCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB3aWR0aDogcm93LndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcm93LmhlaWdodCxcbiAgICAgICAgICAgICAgICBiZ0NvbG9yOiByb3cuc3R5bGUuYmdDb2xvcixcbiAgICAgICAgICAgICAgICBib3JkZXJXaWR0aHM6IHJvdy5zdHlsZS5ib3JkZXJXaWR0aHMsXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3JzOiByb3cuc3R5bGUuYm9yZGVyQ29sb3JzLFxuICAgICAgICAgICAgICAgIGJvcmRlclBhdHRlcm5zOiByb3cuc3R5bGUuYm9yZGVyUGF0dGVybnMsXG4gICAgICAgICAgICAgICAgYm9yZGVyU2hhcGVzOiByb3cuc3R5bGUuYm9yZGVyU2hhcGVzLFxuICAgICAgICAgICAgICAgIHJ4OiByb3cuc3R5bGUucngsXG4gICAgICAgICAgICAgICAgcnk6IHJvdy5zdHlsZS5yeSxcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHJvdy5jZWxscykge1xuICAgICAgICAgICAgcm93Q29udGVudC5wdXNoKEFDZWxsKHtcbiAgICAgICAgICAgICAgICBjZWxsT3B0OiBjZWxsLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRTdHlsZTogZGVmYXVsdFN0eWxlRm9yQ2VsbCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudCgnZycsIHtcbiAgICAgICAgICAgIHJvbGU6ICdyb3cnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgPyBgJHtjbGFzc05hbWV9LXJvdy0ke3Jvd0luZGV4fWAgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sIC4uLnJvd0NvbnRlbnQpO1xuICAgIH0pO1xuICAgIGNvbnN0IHByb3BzRm9yU3ZnID0gc3RhbmRhbG9uZVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICAgICAgICAgeG1sbnNYbGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgIH07XG4gICAgY29uc3QgbWFza05hbWUgPSBgc3ZnLXRhYmxlLW1hc2stJHtjbGFzc05hbWV9LSR7bWFza0lkU3JjKysgJSAxMDAwMDAwMH1gO1xuICAgIHJldHVybiBlbGVtZW50KCdzdmcnLCB7XG4gICAgICAgIC4uLnByb3BzRm9yU3ZnLFxuICAgICAgICB2aWV3Qm94OiBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWAsXG4gICAgICAgIHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSA/IGBzdmctdGFibGUgJHtjbGFzc05hbWV9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgLi4uc3ZnQXR0cnMsXG4gICAgICAgIHN0eWxlOiB7IG92ZXJmbG93OiAndmlzaWJsZScgfSxcbiAgICB9LCBkZWZzICYmIGVsZW1lbnQoJ2RlZnMnLCB7fSwgZGVmcyksIGlzUm91bmRlZENvcm5lciAmJlxuICAgICAgICBlbGVtZW50KCdtYXNrJywge1xuICAgICAgICAgICAgaWQ6IG1hc2tOYW1lLFxuICAgICAgICB9LCBbXG4gICAgICAgICAgICBlbGVtZW50KCdyZWN0Jywge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICBmaWxsOiAnYmxhY2snLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBlbGVtZW50KCdyZWN0Jywge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICByeDogdGFibGVTdHlsZS5yeCxcbiAgICAgICAgICAgICAgICByeTogdGFibGVTdHlsZS5yeSxcbiAgICAgICAgICAgICAgICBmaWxsOiAnd2hpdGUnLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF0pLCBGaWxsZWRBcmVhKHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgPyBgJHtjbGFzc05hbWV9LWZpbGxlZC1hcmVhLWJlaGluZC10YWJsZWAgOiB1bmRlZmluZWQsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGJnQ29sb3I6IHRhYmxlU3R5bGUuYmdDb2xvcixcbiAgICAgICAgYm9yZGVyV2lkdGhzOiB0YWJsZVN0eWxlLmJvcmRlcldpZHRocyxcbiAgICAgICAgYm9yZGVyQ29sb3JzOiB0YWJsZVN0eWxlLmJvcmRlckNvbG9ycyxcbiAgICAgICAgYm9yZGVyUGF0dGVybnM6IHRhYmxlU3R5bGUuYm9yZGVyUGF0dGVybnMsXG4gICAgICAgIGJvcmRlclNoYXBlczogdGFibGVTdHlsZS5ib3JkZXJTaGFwZXMsXG4gICAgICAgIHJ4OiB0YWJsZVN0eWxlLnJ4LFxuICAgICAgICByeTogdGFibGVTdHlsZS5yeSxcbiAgICB9KSwgZWxlbWVudCgnZycsIHtcbiAgICAgICAgcm9sZTogJ3RhYmxlJyxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgPyBgJHtjbGFzc05hbWV9LWNvbnRlbnQtYXJlYWAgOiB1bmRlZmluZWQsXG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke2dldFdpZCh0YWJsZVN0eWxlLm1hcmdpbnMsICdsZWZ0Jyl9ICR7Z2V0V2lkKHRhYmxlU3R5bGUubWFyZ2lucywgJ3RvcCcpfSlgLFxuICAgICAgICAuLi4oaXNSb3VuZGVkQ29ybmVyID8geyBtYXNrOiBgdXJsKCMke21hc2tOYW1lfSlgIH0gOiB7fSksXG4gICAgfSwgLi4ucm93c0NvbnRlbnQpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TVkdUYWJsZUJhc2UuanMubWFwIiwiaW1wb3J0IHsgU1ZHVGFibGVCYXNlIH0gZnJvbSAnLi9TVkdUYWJsZUJhc2UnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21tb24tdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9wcml2YXRlLXR5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb25zdHMnO1xuZXhwb3J0IHsgU1ZHVGFibGVCYXNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY29uc3Qga2ViYWJpemUgPSAoc3RyKSA9PiBzdHIucmVwbGFjZSgvW0EtWl0rKD8hW2Etel0pfFtBLVpdL2csICgkLCBvZnMpID0+IChvZnMgPyAnLScgOiAnJykgKyAkLnRvTG93ZXJDYXNlKCkpO1xuY29uc3QgY29udmVydFZhbCA9ICh2YWwsIGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJyAmJiAhdmFsKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3NvbWV0aGluZyBpcyB3cm9uZy4uIHZhbHVlIHR5cGUgY2Fubm90IGJlIGFycmF5JywgJ2tleTonLCBrZXksICd2YWw6JywgdmFsKTtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModmFsKVxuICAgICAgICAgICAgLm1hcCgoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYCR7a2ViYWJpemUoayl9OiR7dn1gO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJzsnKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3ZhbH1gO1xufTtcbmNvbnN0IGNvbnZlcnRBdHRyVG9IdG1sU3R5bGUgPSAoYXR0ck5hbWUpID0+IHtcbiAgICBpZiAoYXR0ck5hbWUgPT09ICdjbGFzc05hbWUnKVxuICAgICAgICByZXR1cm4gJ2NsYXNzJztcbiAgICBzd2l0Y2ggKGF0dHJOYW1lKSB7XG4gICAgICAgIGNhc2UgJ3ZpZXdCb3gnOlxuICAgICAgICAgICAgcmV0dXJuIGF0dHJOYW1lO1xuICAgIH1cbiAgICBpZiAoYXR0ck5hbWUubWF0Y2goL1tBLVpdKy8pKSB7XG4gICAgICAgIGNvbnN0IG5ld0tleSA9IGtlYmFiaXplKGF0dHJOYW1lKTtcbiAgICAgICAgcmV0dXJuIG5ld0tleTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJOYW1lO1xufTtcbmV4cG9ydCBjb25zdCBjb252ZXJ0VG9LZWJhYkNhc2VQcm9wcyA9IChhdHRycykgPT4ge1xuICAgIGNvbnN0IGtlYmFiQ2FzZVByb3BzID0gT2JqZWN0LmtleXMoYXR0cnMpLnJlZHVjZSgoY3Vyciwga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZEtleSA9IGNvbnZlcnRBdHRyVG9IdG1sU3R5bGUoa2V5KTtcbiAgICAgICAgY29uc3QgY29udmVydGVkID0gYCR7Y29udmVydFZhbChhdHRyc1trZXldLCBrZXkpfWA7XG4gICAgICAgIGlmICghY29udmVydGVkKVxuICAgICAgICAgICAgcmV0dXJuIGN1cnI7XG4gICAgICAgIHJldHVybiB7IC4uLmN1cnIsIFtjb252ZXJ0ZWRLZXldOiBjb252ZXJ0ZWQgfTtcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIGtlYmFiQ2FzZVByb3BzO1xufTtcbmV4cG9ydCBjb25zdCBjcmVhdGVWYW5pbGxhRWxlbWVudCA9ICh0eXBlLCBhdHRycywgLi4uY2hpbGRyZW4pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBfX2ludGVybmFsOiAnc3ZnLXRhYmxlLWVsZW1lbnQtYXMtb2JqJyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgYXR0cnMsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlbmRlcmVkU3RyaW5nID0gKC4uLnJlbmRlcmVkSHRtbCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIF9faW50ZXJuYWw6ICdzdmctdGFibGUtcmVuZGVyZWQtdGV4dCcsXG4gICAgICAgIHR5cGU6ICdnJyxcbiAgICAgICAgYXR0cnM6IHt9LFxuICAgICAgICBjaGlsZHJlbjogW3JlbmRlcmVkSHRtbC5qb2luKCcnKV0sXG4gICAgfTtcbn07XG5leHBvcnQgY29uc3QgX19wcml2YXRlX18gPSB7XG4gICAgY29udmVydFZhbCxcbiAgICBjb252ZXJ0QXR0clRvSHRtbFN0eWxlLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IGNvbnZlcnRUb0tlYmFiQ2FzZVByb3BzIH0gZnJvbSAnLi91dGlscyc7XG5leHBvcnQgY29uc3Qgc3ZnQ29udmVydGVyID0gKGVsZW1lbnQpID0+IHtcbiAgICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5tYXAoYyA9PiBzdmdDb252ZXJ0ZXIoYykpLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudCAhPT0gJ251bWJlcicgJiYgIWVsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIHJldHVybiBzdmdDb252ZXJ0ZXIoZWxlbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gZWxlbWVudDtcbiAgICBpZiAoZWwudHlwZSAmJiBlbC5hdHRycyAmJiBlbC5fX2ludGVybmFsID09PSAnc3ZnLXRhYmxlLWVsZW1lbnQtYXMtb2JqJykge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHR5cGVvZiBlbC5jaGlsZHJlbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gZWwuY2hpbGRyZW5cbiAgICAgICAgICAgIDogZWwuY2hpbGRyZW5cbiAgICAgICAgICAgICAgICA/IGVsLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoYyA9PiAodHlwZW9mIGMgPT09ICdib29sZWFuJyAmJiAhYyA/IG51bGwgOiBzdmdDb252ZXJ0ZXIoYykpKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHYgPT4gdilcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgY29uc3Qga2ViYWJDYXNlUHJvcHMgPSBjb252ZXJ0VG9LZWJhYkNhc2VQcm9wcyhlbC5hdHRycyk7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gT2JqZWN0LmVudHJpZXMoa2ViYWJDYXNlUHJvcHMpXG4gICAgICAgICAgICAubWFwKGVudHJ5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbF0gPSBlbnRyeTtcbiAgICAgICAgICAgIHJldHVybiBgJHtrZXl9PVwiJHt2YWx9XCJgO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcih2ID0+IHYpXG4gICAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICByZXR1cm4gYDwke2VsLnR5cGV9ICR7YXR0cnN9PiR7Y2hpbGRyZW59PC8ke2VsLnR5cGV9PmA7XG4gICAgfVxuICAgIGlmIChlbC5fX2ludGVybmFsID09PSAnc3ZnLXRhYmxlLXJlbmRlcmVkLXRleHQnKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdHlwZW9mIGVsLmNoaWxkcmVuID09PSAnc3RyaW5nJyA/IGVsLmNoaWxkcmVuIDogZWwuY2hpbGRyZW4gPyBlbC5jaGlsZHJlbi5maWx0ZXIodiA9PiB2KS5qb2luKCdcXG4nKSA6ICcnO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50Lm91dGVySFRNTDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdmdDb252ZXJ0ZXIuanMubWFwIiwiaW1wb3J0IHsgU1ZHVGFibGVCYXNlIH0gZnJvbSAnQHNoamVvbjA3MzAvc3ZnLXRhYmxlLWNvcmUnO1xuaW1wb3J0IHsgc3ZnQ29udmVydGVyIH0gZnJvbSAnLi9zdmdDb252ZXJ0ZXInO1xuZXhwb3J0IGNvbnN0IFNWR1RhYmxlID0gKHRhYmxlUHJvcHMpID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gU1ZHVGFibGVCYXNlKHRhYmxlUHJvcHMpO1xuICAgIHJldHVybiBzdmdDb252ZXJ0ZXIoZWxlbWVudCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U1ZHVGFibGUuanMubWFwIiwiaW1wb3J0IHsgU1ZHVGFibGUgfSBmcm9tICcuL1NWR1RhYmxlJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IHsgc2ltcGxlVmFsdWUgfSBmcm9tICdAc2hqZW9uMDczMC9zdmctdGFibGUtY29yZSc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzJztcbmV4cG9ydCBkZWZhdWx0IFNWR1RhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLy8gQHRzLWlnbm9yZVxuZXhwb3J0ICogZnJvbSBcIkBzaGplb24wNzMwL3N2Zy10YWJsZS12YW5pbGxhXCI7XG4vLyBAdHMtaWdub3JlXG5leHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIkBzaGplb24wNzMwL3N2Zy10YWJsZS12YW5pbGxhXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=